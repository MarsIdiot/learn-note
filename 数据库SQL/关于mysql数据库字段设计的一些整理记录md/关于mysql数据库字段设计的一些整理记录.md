

# 关于mysql数据库字段设计的一些整理记录

## 一、基本

### 1、为什么数据库要设置默认值

​	因为我们希望在插入数据时，有意或无意间被忽略的字段能够交由MySQL按你事先预想的方式处理，例如一些默认正常状态码、用户插入数据时候尚未设置的文本字段，诸如此类。

- 在创建字段并且不设置默认值的时候，mysql都会默认给字段加上默认值null

- 如果字段是not null的话，必须插入一个值，若不插入值的话，就会调用默认值。 如果这两个都没有的话，就会报错了。**注意此处：如果插入的是null，则会报错**。

  **总之，假如我们不能保证此字段一定是有值的，则不要使用not null default 定义**

  ~~~mysql
  //二者相同
  `user_id` varchar(20)  COMMENT '创建人',
  `user_id` varchar(20) DEFAULT NULL COMMENT '创建人',
  
  `user_id` varchar(20) NOT NULL COMMENT '创建人',
  `user_id` varchar(20) NOT NULL DEFAULT '' COMMENT '创建人',
  ~~~

### 2、varchar 字段的默认值''和null的区别

#### 1、占用空间问题

（1）c语言：

~~~ini
 1、'\0'，这个表示空，需要消耗存储空间的
 2、 NULL，则表示连这个\0都没有
~~~

（2）mysql:

~~~ini
 1、空值('')是不占用空间的
 2、 MySQL中的NULL其实是占用空间的
~~~

官方文档说明:

~~~ini
:“NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.” 
~~~

​	可见为了表示某个字段是否为空，是需要额外开辟空间存储Null值，而在C语言中空值’不占用存储空间。

（3）结论

**NULL表示“此字段值为空”，而 '' 表示此字段暂未设置值”，即空值**

#### **2、null会影响索引效率**

不仅是空间问题，不使用NULL可以提高索引效率，因为树形索引结构中将NULL也视作一般数据节点。

其实我们在初学mysql的时候，都会看到一段话，那就是mysql建议字段最好为不要为null，尽量为not null。

原话：

```
尽量避免NULL:应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。

null会影响索引的统计，一般会默认null为同一个值，这样这个索引的筛选价值就降低了，影响优化器的判断。当然也可以调整参数，使得null被认为是不同的值。
```

**结论**：也就是说，在设置默认值的时候，尽量不要用Null来当默认值，用空字符串（”）会更好一些。带有null的

默认值还是可以走索引的，只是会影响效率。当然，如果确认该字段不会用到索引的话，也是可以设置为null的。

#### 3、在统计时，”和null的区别

~~~java
1：在进行count()统计某列的记录数的时候，如果采用的NULL值，会别系统自动'忽略'掉，但是空值是会进行统计到其中的。

2： 判断NULL 用IS NULL 或者 is not null,SQL语句函数中可以使用ifnull()函数来进行处理，判断空字符用 =''或者 <>''来进行处理

3: 对于MySQL特殊的注意事项，对于timestamp数据类型，如果往这个数据类型插入的列插入NULL值，则出现的值是当前系统时间。插入空值，则会出现 '0000-00-00 00:00:00'（必须设置timestamp不为空，插入null时才会为当前时间,否则为null;无论timestamp类型是否为空都不能插入空值''）
    一般来说时间记录使用datetime类型，常写在在sql语句中赋值为now()

4：对于空值的判断到底是使用is null 还是 =''要根据实际业务来进行区分。
~~~

时间：无论timestamp/datetime类型是否为空都不能插入空值''

​	timestamp:

![](.\pictures\QQ截图20181217174648.png)

​	datetime:

![](.\pictures\QQ截图20181217174625.png)

#### 4、datetime 和 timestamp

参考：[选择合适的 MySQL 日期时间类型来存储你的时间](https://learnku.com/laravel/t/2495/select-the-appropriate-mysql-date-time-type-to-store-your-time)

1. datetime 

   **说明**

   更像日历上面的时间和你手表的时间的结合，就是指具体某个时间。

   **使用场景**

   记录固定时间如服务器执行计划任务时间 / 健身锻炼计划时间等，在任何时区都是需要一个固定的时间要做某个事情。超出 timestamp 的时间，如果需要时区必须记得时区处理

2. timestamp

   **说明**

    更适合来记录时间，比如我在东八区时间现在是 2016-08-02 10:35:52， 你在日本（东九区此时时间为 2016-08-02 11:35:52），我和你在聊天，数据库记录了时间，取出来之后，对于我来说时间是 2016-08-02 10:35:52，对于日本的你来说就是 2016-08-02 11:35:52。所以就不用考虑时区的计算了。

   **使用场景**

   使用场景如`created_at` `updated_at`；记录经常变化的更新 / 创建 / 发布 / 日志时间 / 购买时间 / 登录时间 / 注册时间等，并且是近来的时间，够用，时区自动处理，比如说做海外购或者业务可能拓展到海外。

3. 时间范围是 timestamp 硬伤（1970-2038），当然 datetime （1000-9999）也记录不了刘备什么时候出生（161 年）

4. 生日可以使用多个字段来存储，比如 year/month/day，这样就可以很方便的找到某天过生日的用户 (`User::where(['month' => 8, 'day' => 12])->get()`)

### 3、varchar（N）

#### 1、历史版本定义

参考：https://blog.csdn.net/ivnetware/article/details/51474695

  4.0版本以下，varchar(50)，指的是50字节，如果存放UTF8汉字时，只能存16个（每个中文3字节）

   **5.0版本以上**，varchar(50)，指的是50字符，无论存放的是数字、字母还是UTF8中文，都可以存放50个

#### 2、存储限制

   需要额外占用字节存放字符的长度:小于255为1个字节，大于255则要2个字节

#### 3、编码限制

   gbk :每个字符最多占用2个字节
   utf8:每个字符最多占用3个字节
   utf8mb4 每个字符最多占用4个字节,中文占3个字节，emoji表情符号 占用4个字节 

测试1： 汉字在不同编码占用字节和字符长度

![QQ截图20181210142051](.\pictures\QQ截图20181210142051.png)

结论：目前版本中 varchar(N) 定义的长度的单位是字符,length(str)表示str占用的字节数，char_length(str)表示str占用的字符数。对于汉字每个字符：gbk 占用2个字节，而utf8占3个字节

测试二： 字母和数字在不同编码占用字节和字符长度

![QQ截图20181210142603](.\pictures\QQ截图20181210142603.png)

结论：无论什么utf8或gbk，字母和数字都只占用1个字符，也占用一个字节。而中文汉字因字符集不同而不同。

4、行长度限制 
　　导致实际应用中varchar长度限制的是一个行定义的长度。 MySQL要求一个***行***的定义长度不能超过65535。若定义的表长度超过这个值，则提示 

~~~ini
　ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to 　　　change some columns to TEXT or BLOBs。
~~~

#### 4、N取值范围逻辑

1)情况一：如果一行只有varchar类型

N的最大值：(65535-1-2)/3=21844
减1是因为实际存储从第2个字节开始
减2则因为要在列表长度存储实际字符长度（参看：2、存储限制）
除3是因为utf8编码限制

注意：N取值范围为21845，超过了自动转换为text类型。

![20181210115844](.\pictures\QQ截图20181210115844.png)

2）情况二：一行包含多个类型

测试：create table t4(c int, c2 char(30), c3 varchar(N)) charset=utf8;

计算：N的最大值：(65535-1-2-4-30*3)/3
​	则此处N的最大值为 (65535-1-2-4-30x3)/3=21812
​	减1和减2与上例相同;
​	减4的原因是int类型的c占4个字节;
​	减30x3的原因是char(30)占用90个字节，编码是utf8。

#### 5、varchar（50）和varchar（100）是否一样？

​	硬盘存储需求一样，内存需求不一样。

​	即对于VARCHAR数据类型来说，硬盘上的存储空间是根据**实际字符长度来分配存储空间的**，而对于内存来说，是使**用N个字符空间的内存**块来保存值，即varchar（50）占用50个字符内存空间，varchar（100）占用100个字符内存空间。

### 4、关于char和varchar的选用

#### 1、定义

众所周知的，char是定长，而varchar是变长。

```java
  char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足．（在检索操作中那些填补出来的空格字符将被去掉）在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）。
```

#### 2、哪个更合适

对于MyISAM表，尽量使用Char，对于那些经常需要修改而容易形成碎片的myisam和isam数据表就更是如此，它的缺点就是占用磁盘空间；

对于InnoDB表，因为它的数据行内部存储格式对固定长度的数据行和可变长度的数据行不加区分（所有数据行共用一个表头部分，这个标头部分存放着指向 各有关数据列的指针），所以使用char类型不见得会比使用varchar类型好。事实上，因为char类型通常要比varchar类型占用更多的空间， 所以从减少空间占用量和减少磁盘i/o的角度，使用varchar类型反而更有利。

#### 3、结论

~~~java
1、在确定字段为短小且定长的时候，用char会好一些

2、在某字段需要'频繁改写'的时候，用char会好一些（因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。）

3、设计varchar()值的时候，不要一股脑的都用varchar(255)：mysql会把表信息放到内存中（查询第一次后，就缓存住 了，linux下很明显，但windows下似乎没有，不知道为啥），这时内存的申请是按照固定长度来的，如果varchar很大就会有问题。

4、关于varchar(255)和varchar(256) ：根据mysql官方文档，varchar(255)需要一个字节记录字段的长度 256以上需要两个字节记录长度。设置长度超过256会有点浪费。

5、因为在业务中使用innoDB多一些，所以尽量还是用varchar（）好一些
~~~

### 5、int(n)中n的含义

**N 表示最大显示宽度**（字段设置zerofill属性时可查看区别），不指定N时，默认为11。

N 的值跟 int(N) 所占多少存储空间或最大能存储多大长度数据并无任何关系。也就是说 int(3)、int(4)、int(8) 在磁盘上**都占用 4 btyes** 的存储空间。

1）数据太长，即实际插入的数据宽度>显示宽度时，数据可正常插入表格中，数据不会被截断

2）数据短，使用zerofill参数填充0，否则显示实际数据

```java
1、插入数据时，当该字段的值的长度小于定义的长度时，会在该值的前面补上相应的0
2、zerofill默认为int(10)
3、当使用zerofill 时，默认会自动加unsigned（无符号）属性，使用unsigned属性后，数值范围是原值的2倍，例如，有符号为-128~+127，无符号为0~256。

总之：无论使用不使用zerofill参数，影响的只是数字是否会自动填充0
```

测试：此处验证zerofill效果时，发现并不能自动填充0：如图

![QQ截图20181210164217.](.\pictures\QQ截图20181210164217.png)



**建议**：在创建表的时候，如果确定不会有负值，**最好指定为ungsighed**，即无符号：0~4294967295；

### 6、约束(CONSTRAINT)

#### 1、非空约束

NOT NULL

#### 2、UNIQUE约束

唯一性约束。*既是一个列级约束，也是一个表级约束。*

保证约束的字段及其组合的值不能重复，保证约束的列的值不能重复。NULL除外。

***在唯一性约束建立之后，系统会自动生成唯一索引。***

#### 3、主键约束

主键字段可以是单字段或者多字段组合，约束条件是既不能重复也不能为空。

**参考一：什么是主键？主键的作用是什么？**

关系型数库中的一条记录中有若干个熟悉，若其中某一个熟悉组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键。

比如：

~~~java
'学生表(学号，姓名，性别，班级)''  
  每个学生的学号是唯一的，学号就是一个主键
'课程表(课程编号，课程名，学分)'
  课程编号是唯一的，课程编号就是一个主键
 '成绩表(学号，课程号，成绩)'
   成绩单中单一一个属性无法标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以，学号和课程号的属性组才是一个主键。
~~~

参考一:[MySQL中的主键以及设置其自增的用法教程](https://www.jb51.net/article/75083.htm)

~~~sql
主键示例
mysql> create table dd( 
  id int primary key not null auto_increment, 
  name varchar(20), 
  time timestamp default current_timestamp 
  ); 
~~~

参考二：[一张表可以有多少个主键](https://www.cnblogs.com/lpxblog/p/7773084.html)

#### 4、外键约束

*FOREIGN KEY* 外键约束

定义在两个表的字段或者表的两个字段上，用于保证两个字段的关系。

~~~java
成绩表中的学号并不是成绩表的主键，但是它和学生表的学号相对应，并且学生表的学号是学生表的主键，则称成绩表中的学号是学生表的外键。

同理，成绩表中的课程号是课程表的外键。
~~~

***主表的数据包括表本身不能被随便删除，从表的数据包括表本身可以随便删除***

  参考:https://blog.csdn.net/Maxiao1204/article/details/52733333

总结：

定义主键和外键主要是为了维护关系数据库的完整性，总结一下：

1.主键是能确定一条记录的唯一标识。

2.外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。

#### 5.CHECK(条件) 检查约束

强制被修饰的字段必须满足CHECK中的定义的条件

~~~sql
ALTER TABLE employee_chris
ADD CONSTRAINT employee_chris_salary_ck
CHECK(salary>2000)
~~~

### 20、实用建议

~~~java
1、如果字段为int 或者varchar类型，那么最好设置字段类型为 not null 并且设置default 0  或者default ''

2、如果字段为text,则既不需要设置not null,也不需要手动设置default 的值

3、关于text字段不能有默认值的问题，这个只针对于手动增加的default属性，如果创建字段不设置default的话，mysql会默认加上一个默认值Null
~~~

## 二、其他

### 1、严格模式

这段文字说的特别好，里面提到了mysql的严格模式。那么什么是严格模式呢？

#### 1、定义

```html
  简单来说就是MySQL自身对数据进行严格的校验（格式、长度、类型等），比如一个整型字段我们写入一个字符串类型的数据，在非严格模式下MySQL不会报错，同样如果定义了char或varchar类型的字段，当写入或更新的数据超过了定义的长度也不会报错。
```

#### 2、如何开启

找到mysql安装目录下的my.cnf（windows系统则是my.ini)文件

在sql_mode中加入STRICT_TRANS_TABLES则表示开启严格模式，如没有加入则表示非严格模式，修改后重启mysql即可

例如这就表示开启了严格模式：

```ini
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES3
```

#### 3、常用场景

~~~java
不支持对not null字段插入null值
不支持对自增长字段插入”值
不支持text字段有默认值
~~~

注：在mysql 5.7中，是默认开启严格模式的。我们自己做本地的项目的时候，可以不开启，但是如果是做线上的项目，建议还是开启严格模式会比较好。



