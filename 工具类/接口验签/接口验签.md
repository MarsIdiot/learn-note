## 开放api接口签名验签

### 1、接口签名验签

**问题提出**

​	在写开放的API接口时是如何保证数据的安全性的？先来看看有哪些安全性问题在开放的api接口中，我们通过http Post或者Get方式请求服务器的时候，会面临着许多的安全性问题，例如：

1. 请求来源(身份)是否合法？
2. 请求参数被篡改？
3. 请求的唯一性(不可复制)

为了保证数据在通信时的安全性，可以采用参数签名的方式来进行相关验证。

**接口签名验签**

​	接口双方为了确保数据参数在传输过程中未经过篡改，需要对接口数据进行**加签**，然后在接口服务器端对接口参数进行**验签**，确保两个签名是一样的，验签通过之后再进行业务逻辑处理。

### 2、不进行验签的方式

接口调用：http://api.test.com/getproducts?参数1=value1.......

如上，这种方式简单粗暴，通过调用getproducts方法即可获取产品列表信息了，但是 这样的方式会存在很严重的安全性问题，没有进行任何的验证，大家都可以通过这个方法获取到产品列表，导致产品信息泄露。
那么，如何验证调用者身份呢？如何防止参数被篡改呢

### 3、MD5参数签名的方式

#### 1、相关定义

**AppId**

唯一标识id

**App key**

​	App Key简称API接口验证序号，是用于验证API接入合法性的。接入哪个网站的API接口，就需要这个网站允许才能够接入，如果简单比喻的话：可以理解成是登陆网站的***用户名*** 

**App Secret**

​	App Secret简称API接口密钥，是跟App Key配套使用的，可以简单理解成是***密码*** 

App Key 和 App Secret ***成对配合***在一起，通过其他网站的协议要求，就可以接入API接口调用或使用API提供的各种功能和数据。 

**简化的场景:**

同一个 app_id 可以对应多个 app_key+app_secret, 这样 平台就可以分配给开发者不一样的权限, 

1 省去 app_id, 他默认每一个用户有且仅有一套权限配置, 所以直接将 app_id = app_key , 然后外加一个app_secret就够了. 
2 省去app_id 和 app_key, 相当于 app_id = app_key = app_secret, 通常用于开放性接口的地方, 特别是很多地图类api 都采用这种模式, 这种模式下, 带上app_id 的目的仅仅是统计 某一个用户调用接口的次数而已了. 

AppID：应用的唯一标识AppKey：公匙（相当于账号）AppSecret：私匙（相当于密码）

token：令牌（过期失效）

#### 2、实现思路

##### 1、分配对应的Appkey、Appsecret；

##### 2、Sign签名，调用API 时需要对请求参数进行签名验证，签名方式如下： 

​    a.参数排序和拼接

​	 按照请求参数名称将所有请求参数按照字母先后顺序**排序**得到：keyvaluekeyvalue...keyvalue  字符串如：将arong=1,mrong=2,crong=3 排序为：arong=1, crong=3,mrong=2  然后将参数名和参数值进行拼接得到参数字符串：arong1crong3mrong2。 

​     b. 加入Appsecret

​	将Appsecret加在参数字符串的头部后进行MD5加密 ,加密后的字符串需**大写**。即得到签名Sign.

​	**sign**=MD5(appSecret+arong1crong3mrong2)

​		=BCC7C71CF93F9CDBDB88671B701D8A35

此时，新api接口代码:

接口调用：http://api.test.com/getproducts?**key**=app_key&**sign**=BCC7C71CF93F9CDBDB88671B701D8A35&参数1=value1&参数2=value2.......

**注：secret 仅作加密使用, 为了保证数据安全请不要在请求参数中使用**

如上，优化后的请求多了key和sign参数，这样请求的时候就需要合法的key和正确签名sign才可以获取产品数据。这样就解决了身份验证和防止参数篡改问题，如果请求参数被人拿走，没事，他们永远也拿不到secret,因为secret是不传递的。再也无法伪造合法的请求。

##### 3、问题

​	如果获取到完整的链接，一直使用key和sign和一样的参数可以正常获取数据，仅仅是如上的优化是不够的。

##### 4、优化

**请求的唯一性**

​	为了防止别人**重复使用请求参数**问题，我们需要保证请求的唯一性，就是对应请求只能使用一次，这样就算别人拿走了请求的完整链接也是无效的。
**唯一性的实现**

​	在如上的请求参数中，我们加入时间戳 ：timestamp（yyyyMMddHHmmss），同样，时间戳作为请求参数之一，也加入sign算法中进行加密。

​	此时：**sign**=MD5(**appSecret**+**请求参数**+**timestamp**)

​			   =BCC7C71CF93F9CDBDB88671B701D8A35

​	新的api接口：

​	http://api.test.com/getproducts**key**=app_key&**sign**=BCC7C71CF93F9CDBDB88671B701D8A35&**timestamp**=201603261407&参数1=value1&参数2=value2.......

如上，我们通过timestamp时间戳用来验证请求是否过期。这样就算被人拿走完整的请求链接也是无效的。

### 4、Sign签名安全性分析

​	可以看出，安全的关键在于参与签名的secret，整个过程中secret是不参与通信的，所以只要保证secret不泄露，请求就不会被伪造。

​	总结：

​	上述的Sign签名的方式能够在一定程度上防止信息被篡改和伪造，保障通信的安全，这里使用的是MD5进行加密，当然实际使用中大家可以根据实际需求进行自定义签名算法，比如：RSA，SHA等。


### 5、MD5算法



### 6、实际应用

接口签名：
1.StringToSign = timestamp + appkey + appSecret + url(不含查询参数) + 查询参数按key的字典序拼接 
2.signature = byte2Hex(MD5(StringToSign))
  byte2Hex：将二进制转为HEX
  MD5:使用md5算法加密字符串

