# 基本基础

参考：https://docs.oracle.com/javase/tutorial/tutorialLearningPaths.html

## 一、入门

### 1、Java技术现象

##### 关于java技术

Java技术既是一种编程语言，也是一种平台

##### Java编程语言

Java编程语言是一种高级语言，可以通过以下所有流行语来表征：

- 简单
- 面向对象
- 分散式
- 多线程
- 动态

- 架构中立
- 手提
- 高性能
- 强大的
- 安全

**a、编译**

首先，需要知道的是，在Java编程语言中，所有的源代码都是以  .java为扩展名。

然后，编译器将源文件 .java编译成 .class文件（字节码文件—Java虚拟机的机器语言）；

运行，.class文件在java虚拟机上运行。

如图所示：

![..\pictures](.\pictures\getStarted-compiler.gif)

**b、跨平台——虚拟机**

通过Java VM，相同的应用程序能够在多个平台上运行。

![ss](.\pictures\helloWorld.gif)

某些虚拟机会在运行时执行其他步骤，为程序提升性能。这些任务包括：如：查找性能瓶颈、重新编译（对本机代码）经常使用的代码。

##### Java平台

一个平台是程序运行的硬件或软件环境。如：Microsoft Windows，Linux，Solaris OS和Mac OS这些手欢迎的平台

大多数平台为操作系统与底层硬件的结合，而Java为纯软件平台，是在上面提到的这些平台（基于硬件）上运行的。

Java平台有两个组件：

- 在*Java虚拟机*（基础）
- 在*Java应用程序编程接口*（API）

Java平台的位置：如图

![1s](.\pictures\getStarted-jvm.gif)

​							API和Java虚拟机将程序与底层硬件隔离开来

### 2、Hello World

- 创建源文件

  源文件包含用Java编程语言编写的代码，您和其他程序员可以理解这些代码。

- 将源文件编译为.class文件

  Java编程语言*compiler*（`javac`）获取源文件并将其文本转换为Java虚拟机可以理解的指令。此文件中包含的指令称为*字节码*。

- 运行程序

  Java应用程序*启动器工具*（`java`）使用Java虚拟机来运行您的应用程序。

## 二、学习Java语言

### 1、面向对象的编程概念   

#### 什么是对象？

~~~scala
An object is a software bundle of related state and behavior.
~~~

对象是有关联的状态和行为的软件包。

真实世界的对象共享两个特征：它们都具有*状态*和*行为*。

在编程语言中，对象将其状态存储在*字段*（某些编程语言中的变量）中，并通过*方法*（某些编程语言中的函数）公开其行为。如图，一个软件对象：

![](.\pictures\concepts-object.gif)

原则：方法对对象的内部状态进行操作，并作为对象到对象通信的主要机制。隐藏内部状态并要求通过对象的方法执行所有交互称为*数据封装* - 面向对象编程的基本原则

#### 什么是类？

类是创建对象的蓝图或原型。展示了即使是一个简单的类也可以清晰地模拟状态和行为。

#### 什么是继承？

~~~scala
Inheritance provides a powerful and natural mechanism for organizing and structuring your software. 
~~~

继承为组织和构建软件提供了强大而自然的机制。

面向对象编程允许类*继承*其他类中常用的状态和行为。Java编程语言中，允许每个类具有一个直接超类，并且每个超类都有可能存在无限数量的子类。

#### 什么是接口？

~~~scala
An interface is a contract between a class and the outside world. When a class implements an interface, it promises to provide the behavior published by that interface.
~~~

接口是一个类和外部世界之间的契约。当类实现接口时，它提供该接口发布的行为。

在最常见的形式中，接口是一组具有空体的相关方法。

如果你的类声称实现了一个接口，那么该接口定义的所有方法必须出现在其源代码中才能成功编译该类。

#### 什么是包？

~~~scala
A package is a namespace for organizing classes and interfaces in a logical manner. Placing your code into packages makes large software projects easier to manage.
~~~

包是用于以逻辑方式组织类和接口的命名空间。将代码放入包中可以使大型软件项目更易于管理。

Java平台提供了一个适合在您自己的应用程序中使用的庞大的类库（一组包）。该库称为“应用程序编程接口”，简称“API”。它的包代表了最常用于通用编程的任务。

### 2、语言基础知识

#### 变量variables

在Java编程语言中，使用术语“字段”和“变量”; 这是新开发人员之间常见的混淆因素，因为两者往往都是指同一件事。字段指类的属性变量。局部变量和参数总是被归类为“变量”（而不是“字段”）

**原始数据类型**

Java编程语言是静态类型的，这意味着必须首先声明所有变量才能使用它们。这包括声明变量的类型和名称，如您所见：

```java
int gear = 1;
```

这样做会告诉程序一个名为“gear”的字段存在，保存数字数据，初始值为“1”.

默认值：

​	在声明字段时并不是总是需要分配值。如果未初始化将由编译器设置默认值。一般来说，此默认值为零或`null`取决于数据类型。然而，依赖于这样的默认值通常被认为是糟糕的编程风格。

下表总结了上述基本八大数据类型的默认值。

| **Data Type**          | **Default Value (for fields)** |
| ---------------------- | ------------------------------ |
| byte                   | 0                              |
| short                  | 0                              |
| int                    | 0                              |
| long                   | 0L                             |
| float                  | 0.0f                           |
| double                 | 0.0d                           |
| char                   | '\u0000'                       |
| String (or any object) | null                           |
| boolean                | false                          |

但是需要主义的是，局部变量略有不同; 编译器永远不会为未初始化的局部变量分配默认值。如果无法初始化声明它的局部变量，请确保在尝试使用它之前为其赋值。访问未初始化的局部变量将导致编译时错误。

**数组**

声明数组

```java
//声明一个整数数组
int [] anArray;
//创建一个整数数组
anArray = new int [10];//如果缺少此语句，则编译器会输出如下错误，并且编译失败，变量anArray可能尚未初始化。
注意：不建议将括号放在数组名后，虽然没错。
int anArray [] ;
```

操作数组

`java.util.Arrays`该类中的方法提供的一些其他有用的操作是：

- 在数组中搜索特定值以获取放置它的索引（`binarySearch`方法）。
- 比较两个数组以确定它们是否相等（`equals`方法）。
- 填充数组以在每个索引处放置特定值（`fill`方法）。
- 按升序对数组进行排序。这可以使用该`sort`方法顺序完成，也可以使用`parallelSort`Java SE 8中引入的方法同时完成。多处理器系统上的大型数组的并行排序比顺序数组排序更快。

#### 运算符operators

#### 表达式、语句、块

运算符是用于构建计算值的表达式；表达式是陈述的核心组成部分；语句可以分组为块。

**表达式**

表达式中，可使用平衡括号精确指定表达式的计算方式：

```java
x + y / 100 //含糊不清
(x + y）/ 100 //明确无误，推荐
x +（y / 100）//明确，推荐
```

在编写复合表达式时，请明确并用括号表示应首先评估哪些运算符。这种做法使代码更易于阅读和维护。

**块**

*块*是一组平衡的括号之间的零条或多个语句，并且可以在任何地方使用单个语句是允许的。

#### 控制流程语句

控制流程语句通过使用决策（if-then，if-then-else,switch）、循环(for，while，do-while)、分支(break，continue,return)来打破执行流程。

**`if-then-else`与`switch`的选用**

决定是使用`if-then-else`语句还是`switch`语句是基于可读性和语句正在测试的表达式。一个`if-then-else`语句可以测试基于值或条件的范围的表达式，而`switch`语句测试仅基于一个整数，枚举值或表达式`String`对象。

**switch**

首先，`break`声明的使用。switch中，每个case后break声明是必要的，因为switch中无论有多少case分支直到遇到break才停止。

在Java SE 7及更高版本中，可以在`switch`语句的表达式中使用`String`对象。String`的`switch表达式进行比较，`case`就好像`String.equals`正在使用该 方法一样。

但是要确保switch语句中的表达式是否为`null`。确保任何`switch`语句中的表达式不为null以防止`NullPointerException`被抛出。

**for**

可用于循环集合和数组。for（int item：numbers）

**`while`与`do-while`**

`do`块中的语句总是至少执行一次

### 3、类和对象

#### 类

**类声明**

通常，类声明可以按顺序包含这些组件：

1. 修饰符，例如*public*，*private*以及稍后您将遇到的许多其他修饰符。
2. 类名，首字母大写。
3. 类的父级（超类）的名称（如果有）以关键字*extends开头*。一个类只能*扩展*（子类）一个父类。
4. 由类实现的以逗号分隔的接口列表（如果有），前面是关键字*implements*。一个类可以*实现*多个接口。
5. 类体，被括号围绕，{}。

**声明成员变量**

有几种变量：

- 类中的成员变量 - 这些变量称为*字段*。
- 方法或代码块中的*变量* - 这些*变量*称为*局部变量*。
- 方法声明中的变量 - 这些变量称为*参数*。

 **命名方法**

- 方法名称中的第一个（或唯一）单词应该是动词。后跟形容词，名词等

**方法重载Overload**

类中的方法具有不同的参数列表。

使用须知：

- 重载方法由传递给方法的参数的数量和类型区分。在代码示例中，`draw(String s)`并且`draw(int i)`是不同且独特的方法，因为它们需要不同的参数类型；
- 你不能声明多个具有相同名称和相同数量和类型的参数的方法，因为编译器无法区分它们；
- 在区分方法时，编译器不考虑返回类型。

注意：

  应谨慎使用重载方法，因为它们会使代码的可读性降低。

**构造函数**

构造函数声明看起来像方法声明，除了它使用类的名称并且没有返回类型。

区分：与方法一样，Java平台根据列表中的参数数量及其类型来区分构造函数。

使用须知：

- 可以不必为类提供任何构造函数。它会调用超类或隐含超类Object的无参构造函数；
- 可以由修饰符，但是无返回类型

#### 对象

**创建对象**

```java
Point originOne = new Point（23,94）;
Rectangle rectOne = new Rectangle（originOne，100,200）;
Rectangle rectTwo = new Rectangle（50,100）;
```

上面每一个包含三个部分：

1、声明：`Point `  `originOne` = new Point（`23`,`94`）;以黑底设置的代码将变量名称与对象类型相关联的所有变量声明。

2、实例化：new关键字创建对象。

3、初始化：new后面的是对构造函数的调用，初始化新对象。

需要注意的是：如果您这样声明  Point `originOne`；，则在实际创建并分配对象之前，其值是不确定的，这种简单地声明引用变量不会创建对象；另外，在使用改对象前，必须指定对象,否则，编译器会报错。

**垃圾收集器**

Java有自动垃圾回收机制，可以让我们在开发时根据需要创建任何对象而不用释放或处理。

当没有对该对象的引用时，对象有资格被进行回收。当变量超过范围时，通常会删除变量中保存的引用。或者，开发者手动设置变量为默认值null来显示删除对象引用。

请记住，程序可以对同一对象进行多次引用（赋值，指向不同的内存地址）；在对象被回收之前，必须删除对对象的所有引用。

**this关键字**

`this`是对*当前对象*的引用- 正在调用其方法或构造函数的对象

使用`this`关键字的最常见原因是因为字段被方法或构造函数参数遮蔽。

如：

```java
//构造
    public Point（int x，int y）{
        this.x = x;
        this.y = y;
    }
```

另外，使用this在同一类中实现构造函数互调。

```java
public class Rectangle {
    private int x, y;
    private int width, height;
        
    public Rectangle() {
        this(0, 0, 1, 1);
    }
    public Rectangle(int width, int height) {
        this(0, 0, width, height);
    }
    public Rectangle(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    ...
}
```

使用须知：构造函数互调时，则另一个构造函数的调用必须是构造函数中的第一行

**访问级别**

| 修饰符      | 类   | 包   | 子类 | 世界 |
| ----------- | ---- | ---- | ---- | ---- |
| `public`    | y    | y    | y    | y    |
| `protected` | y    | y    | y    | n    |
| 没有修饰语  | y    | y    | n    | n    |
| `private`   | y    | n    | n    | n    |

访问级别以两种方式影响开发者。首先，在使用别人的时，访问级别将确定你可以使用这类的哪些成员；其次，在自己编写类时，你需要确定成员变量和方法应具有的访问级别。

**初始化字段**

开发者可以在声明字段时为初始化字段

```java
public class BedAndBreakfast {

    // initialize to 10
    public static int capacity = 10;

    // initialize to false
    private boolean full = false;
}
```

但是，如果初始化字段时包含对字段的逻辑处理，显然现在的初始化手段显得太过单一。实例变量可以在构造函数中初始化，而类变量不可以。于是为了为类变量提供相同的功能，Java语言提供——静态初始化块。

**静态初始化块**

静态初始化块有static关键字和大括号{}组成。

```java
static { 
    //初始化需要的代码在这里
}
```

一个类可以有任意数量的静态初始化块，并且可以出现在类的任何位置。运行时系统根据其出现顺序调用。

另外，静态块有一个替代方法——编写一个私有静态方法：

```java
class Whatever {
    public static varType myVar = initializeClassVariable();
        
    private static varType initializeClassVariable() {

        // initialization code goes here
    }
}
```

私有静态方法的优点是，如果需要重新初始化类变量，它们可以在以后重用。

#### 嵌套类

Java语言语序开发者在一个类中定义另一个类，即嵌套类。

```java
class OuterClass {
    ...
    class NestedClass {
        ...
    }
}
```

**术语：**  嵌套类分为两类：静态和非静态。声明`static`的*嵌套类*称为*静态嵌套类*。非静态嵌套类称为*内部类*。

```java
class OuterClass {
    ...
    //静态嵌套类，无权访问OuterClass的其他成员
    static class StaticNestedClass {
        ...
    }
    
    //内部类，可以访问OuterClass的其他成员，即使它们被声明为私有。
    class InnerClass {
        ...
    }
}
```

**为何使用嵌套类**

- 如果一个类对另一个类有用，那么二者包含在一起是合乎逻辑的。
- 增加了封装。如果B是A的嵌套类，则B可以直接访问A的成员变量，而B对外是隐藏的。
- 易读、方便维护代码。

**静态嵌套类**

与类方法和类变量一样，静态嵌套类和其外部类相关联。和静态方法一样，静态嵌套类不能直接访问实例变量和实例方法。

访问静态嵌套类：

​	OuterClass.StaticNestedClass

为静态嵌套类创建对象：

​	OuterClass.StaticNestedClass nestedObject =new OuterClass.StaticNestedClass（);

**内部类**

与实例方法和实例变量一样，内部类与其封闭类的实例相关联。可以访问任何成员变量或方法。

实例化内部类：首先实例化外部类，然后使用外部对象创建内部类。

​	OuterClass  outerObject=new  OuterClass();

​	OuterClass.InnerClass innerObject = outerObject.new InnerClass（）;

**另外类型的内部类**

本地类：在方法体内声明的内部类；

匿名类：方法体内声明内部类，而无需命名该类

#### 枚举类型

枚举类型是一种特殊的数据类型，将变量预定为一组常量。

其枚举类型字段名需要大写。

### 4、注解Annotation

注解（一种元数据）提供与不属于程序本身的数据。注解对其注解的代码没有直接影响。

用途：

- **编译器的信息** - **编译器**可以使用注解检测错误或抑制警告。
- **编译时和部署时处理** - 软件工具可以处理注解信息以生成代码，XML文件等。
- **运行时处理** - 可以在运行时检查某些注解。

#### 1、注解基础认识

1）格式

@entity，其at符号（`@`）向编译器指示后面的内容是注解。

- 如果只有一个元素且key为value，则key可以省略。

  @SuppressWarnings（value =“unchecked”）

  简写：@SuppressWarnings（“unchecked”）

- 如果注解没有元素，则可以省略括号。

  @Author（name =“Jane Doe”）
  @EBook 

- 如果注解具有相同的类型，则称为重复注解：

  @Author（name =“Jane Doe”）
  @Author（name =“John Smith”）

  从Java SE 8发行版开始，支持重复注释

2）可使用的位置

注解可用于声明：类、字段、方法和其他程序元素的声明。

在Java SE8之前，注释只能用于声明。现在，可以应用于任何类型。如下是类型注解的例子：

- 类实例创建表达式:

  ```
      new @Interned MyObject();
  ```

- 类型转换：

  ```
      myString = (@NonNull String) str;
  ```

- 实现声明:

  ```
      class UnmodifiableList<T> implements
          @Readonly List<@Readonly T> { ... }
  ```

- 抛出的异常声明:

  ```
      void monitorTemperature() throws
          @Critical TemperatureException { ... }
  ```

#### 2、声明注解类型

```java
@interface ClassPreamble {
   String author();
   String date();
   int currentRevision() default 1;
   String lastModified() default "N/A";
   String lastModifiedBy() default "N/A";
   // Note use of array
   String[] reviewers();
}
```

注解类型定义类似于接口定义，在关键字interface前面是at符号（@）。注解类型是一种接口形式。

使用注意：

```java
@ClassPreamble (
   author = "John Doe",
   date = "3/17/2002",
   currentRevision = 6,
   lastModified = "4/12/2004",
   lastModifiedBy = "Jane Doe",
   // 注意数组注解格式
   reviewers = {"Alice", "Bob", "Cindy"}
)
```

另外：

  要使注解信息@ClassPreamble显示在Javadoc生成的文档中，必须使用@Documented注解。如下所示：

```java
//导入此项以使用@Documented
import java.lang.annotation。*; 
@Documented 
@interface ClassPreamble { 
   //注释元素定义 
}
```

#### 3、预定义的注解类型

Java SE API中预定义了一组注解类型。

##### 1、java.lang中预定义的注解类型

包括：@Deprecated(弃用)，@Override（重写），@SuppressWarnings（抑制警告）

1）`@Deprecated`

​	表示已*弃用*标记的元素，不应再使用。可使用在类、方法、字段，编译器会生成警告，会提示开发者不推荐使用。

```java
	// Javadoc注释
    / ** 
     * @deprecated 
     * 解释为何弃用 
     * / 
    @Deprecated 
    static void deprecatedMethod（）{} 
```

需要注意的是：Javadoc标记以小写*d*开头，注解以大写*D*开头

2）`@Override`

注释通知编译器该元素旨在覆盖超类中声明的元素(在接口和继承中)

使用须知：

​	虽然在重写时不必须使用此注解，但为了防止出错在开发中常常会加上。在被标记了`@Override`方法如果无法正确覆盖超类中的方法，则编译器会报错。

3）`@SuppressWarnings`

此注解会告诉编译器抑制指定的警告。

假如使用了不推荐的方法，编译器通常会生成警告。但是，如果使用`@SuppressWarnings`注解让警告被抑制，即不会生成警告。

```java
// 使用不推荐使用的方法
//告诉 编译器不要生成警告
@SuppressWarnings（“deprecation”） 
   void useDeprecatedMethod（）{ 
      //弃用方法
       objectOne.deprecatedMethod（）; 
    }
```

如果需要抑制多中警告，可以使用以下语法：

```java
@SuppressWarnings（{“unchecked”，“deprecation”}）
```

##### 2、适用于其他注释的注释

适用于其他注释的注释称为`元注释`，是在java.lang.annotation定义。

**@Retention** [`@Retention`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html) annotation指定标记注解的存储方式：

- `RetentionPolicy.SOURCE` - 标记的注释仅保留在源级别中，并由编译器忽略。
- `RetentionPolicy.CLASS` - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。
- `RetentionPolicy.RUNTIME` - 标记的注释由JVM保留，因此运行时环境可以使用它。

使用如:@Retention（value = RUNTIME）

**@Documented** [`@Documented`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html)注解表明，是否需要将注解使用Javadoc工具记录。默认，不会包含在Javadoc中。

**@Target** [`@Target`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html)注解标记另一个注解，以限制可以应用注解的Java元素类型。目标注解指定以下元素类型之一作为其值：

- `ElementType.ANNOTATION_TYPE` 可以应用于注解类型。
- `ElementType.CONSTRUCTOR` 可以应用于构造函数。
- `ElementType.FIELD` 可以应用于字段或属性。
- `ElementType.LOCAL_VARIABLE` 可以应用于局部变量。
- `ElementType.METHOD` 可以应用于方法级注释。
- `ElementType.PACKAGE` 可以应用于包声明。
- `ElementType.PARAMETER` 可以应用于方法的参数。
- `ElementType.TYPE` 可以应用于类的任何元素。

使用如： @Target（value = ANNOTATION_TYPE）

**@Inherited** [`@Inherited`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html)注解表明注解类型可以从超类继承。

当开发者查询注解类型并且该类没有此注解类型时，将会查询超类的。

使用须知：此注释仅适用于类声明。

[`@Repeatable`](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html)Java SE 8中引入的**@Repeatable**注解表明标记的注释可以多次应用于相同的声明或类型使用

##### 3、类型注释和可插入类型系统

***历史问题***

在Java SE8之前，注释只能用于声明。现在，可以应用于任何类型。如下是类型注解的例子：

- 类实例创建表达式:

  ```
      new @Interned MyObject();
  ```

- 类型转换：

  ```
      myString = (@NonNull String) str;
  ```

- 实现声明:

  ```
      class UnmodifiableList<T> implements
          @Readonly List<@Readonly T> { ... }
  ```

- 抛出的异常声明:

  ```
      void monitorTemperature() throws
          @Critical TemperatureException { ... }
  ```

***目的***

类型注解是为了支持改进Java程序分析，以确保更强的类型检查。

Java SE 8版本不提供类型检查框架，但它允许您编写（或下载）类型检查框架，该框架实现为与Java编译器结合使用的一个或多个可插入模块。

***@NonNull的使用***

```java
@NonNull String str;
```

当您编译代码（包括`NonNull`命令行中的模块）时，编译器会在检测到潜在问题时输出警告，允许您修改代码以避免错误。在更正代码以删除所有警告后，程序运行时不会发生此特定错误。

***三方检查框架***

在许多情况下，您不必编写自己的类型检查模块。有第三方为你完成了这项工作。例如，您可能希望利用华盛顿大学创建的Checker Framework。该框架包括一个`NonNull`模块，一个正则表达式模块和一个互斥锁模块。有关更多信息，请参阅 [Checker Framework](http://types.cs.washington.edu/checker-framework/)。

##### 4、重复注解

在Java 8之前，相同注释的两个实例无法应用于单个元素。

Java 8使用`@Repeatable`注释提供了一种更清晰，更透明的使用容器注释的方法。

**以下是自定义重复注解的例子：**

第一步：声明一个可重复的注解类型Author

```java
@Retention(RetentionPolicy.RUNTIME)
//告诉Java将多个@Author注释视为被@Authors容器包围。也可以使用Class.getAnnotationsByType()通过它自己的类来访问@Author数组，而不是通过它的容器
@Repeatable(Authors.class)
public @interface Author {
    String name();
    String mostFamousBook();
}
```

第二步：声明容器注解类型Authors

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Authors {
    Author[] value();
}
```

第三步：使用

```java
@Author("Mary")
@Author("Sam")
public class Test {
    public static void main(String[] args) {
        Author[] authors = Test.class.getAnnotationsByType(Author.class);
        for (Author author : authors) {
            System.out.println(author.value());
            // Output:
            // Mary
            // Sam
        }
    }
}
```

### 5、接口和继承

#### 1、接口

**为什么要使用接口**

总的来说：便于理解与维护，给不同模块或接口的开发者定一个合同，大家必须遵循这个合同规范进行开发。

简单来说就是：把使用接口和实现接口的人分开。实现接口的人不必关心谁去使用，而使用接口的人也不用关心实现细节。

**几点关于接口的意义**

1、重要性：在[Java语言](https://www.baidu.com/s?wd=Java%E8%AF%AD%E8%A8%80&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)中， abstract class 和interface 是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的 面向对象能力。

2、简单/规范性/强制性：如果一个项目比较庞大，那么就需要一个能理清所有业务的架构师来定义一些主要的接口，这些接口不仅告诉开发人员你需要实现那些业务，而且也将命名规范限制住了（防止一些开发人员随便命名导致别的程序员无法看明白）。

3、维护、拓展性：比如有一个类，实现了某个功能，突然有一天，发现这个类满足不了需求了，然后又要[重新设计](https://www.baidu.com/s?wd=%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)这个类，更糟糕是你可能要放弃这个类，那么其他地方可能有引用他，这样修改起来很麻烦。只需修改引用的不同（即实现类的不同）如：USB接口插什么读什么。

4、安全、严密性：接口是实现软件松耦合的重要手段，它描叙了系统对外的所有服务，而不涉及任何具体的实现细节。这样就比较安全、严密一些（一般软件服务商考虑的比较多，jdk中很多方法就是实现了某个接口）

**接口在使用中的注意几点**

- 接口是系统中最高层次的抽象类型；
- 接口本身必须十分稳定，接口一旦定制，就不允许随意修改，否则对接口实现类以及接口访问都会造成影响。
- 接口方法默认修饰符为public

**默认方法**

目的：默认方法使您能够向现有接口添加新功能，并确保与为这些接口的旧版本编写的代码的二进制兼容性。

​	当增加新的方法时，如果将它们添加到原接口，那么实现接口不得不重写它们实现。如果将它们作为默认方法添加，那么接口以及实现该接口的类都将持有新加的方法。

~~~java
public interface DoItNew {
    void doSomething(int i, double x);
    int doSomethingElse(String s);

    //默认方法必须实现
    default boolean didItWork(int i, double x, String s) {
        return false;
    }

    //静态方法必须实现
    static  boolean didiItWorks(int i, double x, String s) {
        return false;
    }
}
~~~

**静态方法**

静态方法是一种只和本类有关联的方法，不和其他对象产生联系。该类的每个实例都共享其静态方法。

**接口小结**

- 接口声明可以包含一般方法、默认方法、静态方法和常量的定义。具有实现的方法是默认方法和静态方法；
- 实现类必须实现接口中声明的所有方法。（除了默认和静态已自身实现的）；
- 可以在任何使用类型的地方使用接口名称。

#### 2、继承

##### 1、基本认识

**定义**

从另一个类派生的类称为子类（也称派生类、扩展类）；派生子类的类成为超类（也称基类、父类）。

子类可以继承超类所有成员（字段、方法、嵌套类）。构造函数不是成员，因此它们不是由子类继承的，但是可以在子类中调用超类的构造函数（super()）。

**可在子类中的操作**

子类可继承父类的所有公共成员和受保护的成员。如果在同一包下，还可继承父类的包私有成员(protected)。

- 可以编写一个子类构造函数，它可以隐式地或使用关键字来调用超类的构造函数`super`

**父类的私有方法**

子类不继承父类的私有成员。但可以通过继承父类的方法间接访问。

由于嵌套类可以访问封闭类的所有私有成员-包含字段和方法。因此，子类继承公共或受保护嵌套类可以间接访问父类的私有成员。

**类型转换原则**

*向上原则*

判断其对象类型：可使用`instanceof`运算符

##### 2、覆盖（另称：重写override）与隐藏

二者都是由于子类拥有与父类相同的方法签名(方法名、参数个数以及类型)和返回值类型导致；覆盖是实例方法，而隐藏是静态方法。

示例：

```java
public class ClassA {
    public void methodOne(int i) {
    }
    public void methodTwo(int i) {
    }
    public static void methodThree(int i) {
    }
    public static void methodFour(int i) {
    }
}

public class ClassB extends ClassA {
    public static void methodOne(int i) {//编译错误
    }
    public void methodTwo(int i) {//覆盖
    }
    public void methodThree(int i) {//编译错误
    }
    public static void methodFour(int i) {//隐藏
    }
}
```

##### 3、小结

1、除了`Object`类之外，类只有一个直接超类。类继承其所有超类中的字段和方法，无论是直接还是间接。子类可以覆盖它继承的方法，也可以隐藏它继承的字段或方法。（注意隐藏字段通常是糟糕的编程习惯。）

2、本`Object`类是类层次结构的顶部。所有类都是此类的后代，并从中继承方法。从继承的有用的方法`Object`包括`toString()`，`equals()`，`clone()`，和`getClass()`。

3、可以通过`final`在类的声明中使用关键字来阻止类被子类化。同样，可以通过将方法声明为final方法来防止子类覆盖该方法。

4、抽象类只能被子类化；无法被实例化。抽象类可以包含声明但未实现的抽象方法 ；子类提供抽象方法的实现。

### 6、数字和字符串

#### 1、数字

**数字类**

所有的数字包装类都是抽象类Number的子类:

![](D:\ztl\笔记\Java基础\关于官方文档学习笔记记录(20190222)md\01基本基础md\pictures\objects-numberHierarchy.gif)

**注意：**`Number`此处未讨论 其他四个子类。`BigDecimal`并`BigInteger`用于高精度计算。`AtomicInteger`并`AtomicLong`用于多线程应用程序。

使用Number对象子类而非基元类型的3个理由：

- 如果作为方法的参数，通常期望的是一个对象(通常是在操作数字集合);	
- 使用有类定义的常量，如`MIN_VALUE`和`MAX_VALUE`，提供数据类型的上限和下限；
- 使用类方法将值转换为其他基本类型，从而转换为字符串和从字符串转换，以及在数字系统之间进行转换（十进制、八进制等）；

以下是Number类的方法（Java JDK 1.8版本）：

![](D:\ztl\笔记\Java基础\关于官方文档学习笔记记录(20190222)md\01基本基础md\pictures\QQ截图20190226154302.png)

**格式化数字打印输出**

https://docs.oracle.com/javase/tutorial/java/data/numberformat.html

**数学函数Math类**

Math类中包含丰富的数学函数，如三角函数，随机数等。其函数方法大多为静态方法，可以直接调用。

#### 2、字符串String

##### 1、基本认识

**创建**

String提供了10几种构造函数，方便开发者根据多种类型的参数进行创建String对象，具体如下：

![](D:\ztl\笔记\Java基础\关于官方文档学习笔记记录(20190222)md\01基本基础md\pictures\QQ截图20190226164857.png)

**字符拼接**

只需注意： Java编程语言不允许文字字符串跨越源文件中的行，因此必须`+`在多行字符串中的每行末尾使用连接运算符。例如：

```java
String quote = 
    "Now is the time for all good " +
    "men to come to the aid of their country.";
```

##### 2、数字与字符串互转

##### 3、操纵字符串

##### 4、比较字符串(匹配)

##### 5、String类型空判断（空串与null的区别）

**原因**

开发人员总是避免不了要判断空类型，后台返回数据中某个值可能是"",有的时候某个值又是null,我们应该如何正确判断。

**概念**

null 指这个字符串变量不指向内存中的任何地址，即它不是对象也不会分配内存空间了，引用为空。此时如果调用它的方法如length()会报空指针异常。

""表示它指向一个长度为0的字符串，在内存中分配了空间，引用了一个空串，所以""是对象。

"   " 是由长度的字符串。             

**使用说明**

效率最高的判断方式：先判断字符串不是null,然后再判断其长度不为0。

~~~java
if(str !=null && str.length()!=0){
      //执行字符串不为空的操作
}else{
     //执行字符串为空的操作
}
~~~

在上面的例子中，str.length()!=0 可写为  !str.empty()。另外，也可用  str.equals("")代替。

 另外，根据需求有不同的写法：

```java
if (str ==null || str.length()== 0){
    //执行字符串不空的操作
}else{
    //执行字符串不为空的操作
}                                                                
```
##### 6、String 与 StringBuilder区别

StringBuilder与String的最大区别：在于前者是可变的(StringBuilder内置可变数组，动态储存数据)。

在StringBuilder类上，比String多了如append()`和`insert()`方法。

**注意：**  还有一个`StringBuffer`类与该类*完全相同*`StringBuilder`，只是由于其方法已同步而具有线程安全性。线程将在关于并发的课程中讨论。

### 7、泛型 Generics

1、为什么使用泛型

- 编译时更强的类型检查 （可使用泛型的通用算法）

- 不用类型转换

  ```java
  //不用泛型时，要求类型转换
  List list = new ArrayList();
  list.add("hello");
  String s = (String) list.get(0);
  //使用了泛型，不用转换
  List<String> list = new ArrayList<String>();
  list.add("hello");
  String s = list.get(0); 
  ```

- 开发者可实现泛型算法  (对不同类型的集合自定义算法，更安全、易于阅读)

总之：泛型的工作就是：消除代码中的强制类型转换，同时获得一个附加的类型检查层，该检查层可以防止有人将错误类型的键或值保存在集合中。这就是泛型的工作。

2、泛型类

T类型可以变量可以是开发者指定的任何非基本类型：任何类类型、接口类型、数组类型等。

```java
//普通类
public class Box {
    private Object object;
    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
//泛型类
public class Box<T> {
    // T stands for "Type"
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

键入参数命名约定：

- E - Element (used extensively by the Java Collections Framework)
- K - Key
- N - Number
- T - Type
- V - Value
- S,U,V etc. 

调用和实例化泛型类型

​	Box<Integer> integerBox = new Box<Integer>()，需将T替换为具体类型：

​	当时，也可以省略为：Box<Integer> integerBox = new Box<>()；

### 8、注解

Javadoc注释的使用

编写示例：

```java
package controller;

/** 我的数组帮助类
 *定义一个用于操作数组的工具类。
 *比如：获取最值，排序，折半。
 *@author 张三
 *@version V1.0
 */
public class ArrayTool
{

    /**
     该类的空参数构造函数。
     */
    private ArrayTool222222(){}

    /**
     获取int数组的最大值。
     @param arr 用于接收一个int类型的数组。
     @return 返回该数组中的最大值。
     */
    public static int getMax(int[] arr)
    {
        int max = arr[0];
        for(int x=1; x<arr.length; x++)
        {
            if(arr[x]>max)
                max = arr[x];
        }

        return max;
    }
    /**
     对int数组进行从小打到的排序。
     @param arr 用于接收一个int类型的数组。
     */
    public static void bubbleSort(int[] arr)
    {
    }
}
```

在控制台输入生成文档html

~~~java
javadoc  -encoding UTF-8  -d help src\main\java\controller\ArrayTool.java
//使用通配符批量生成
javadoc  -encoding UTF-8  -d help src\main\java\controller\*.java
~~~

结果图

![](D:\ztl\笔记\Java基础\关于官方文档学习笔记记录(20190222)md\01基本基础md\pictures\QQ截图20190225170447.png)



## 三、基本Java类

### 1、异常

扩展参考(实战指南)：https://www.cnblogs.com/hihtml5/p/6505994.html

#### 1、什么是异常

**异常类型**

![](D:\ztl\笔记\Java基础\关于官方文档学习笔记记录(20190222)md\01基本基础md\pictures\20171010184746692.jpg)

**谁来处理（重要）**

在方法抛出异常后，运行时系统会尝试查找要处理它的内容(异常处理程序)，其具体流程如下图：

![](D:\ztl\笔记\Java基础\关于官方文档学习笔记记录(20190222)md\01基本基础md\pictures\QQ截图20190301173300.png)

说明：搜索从发生错误的方法开始，并按照调用方法的相反顺序继续通过调用堆栈。找到适当的处理程序后，运行时系统会将异常传递给处理程序。如果抛出的异常对象的类型与处理程序可以处理的类型匹配，则认为异常处理程序是合适的。

异常不外乎就是理解其异常是如何抛出的，还有是如何进行捕获的，这其中包含了5个关键字：throws、throw、try、catch、finally.具体请看如下例程：

```java
public class TestException {

    public static void main(String[] args) {
        TestException te = new TestException();
        try {
            te.method1();
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            System.out.println("run finally code.");
        }
    }

    public void method1() throws Exception {
        this.method2();   
    }
    public void method2() throws Exception {
        this.method3();
    }
    public void method3() throws Exception{
        throw new Exception("Exception in method3");
    }
}
```
以上代码示例运行流程图如下：

​	![](D:\ztl\笔记\Java基础\关于官方文档学习笔记记录(20190222)md\01基本基础md\pictures\919493-20170620222932913-2091642405.jpg)

这段代码执行后控制台打印如下信息：

```jade
java.lang.Exception: Exception in method3
at test.TestException.method3(TestException.java:23)
at test.TestException.method2(TestException.java:19)
at test.TestException.method1(TestException.java:15)
at test.TestException.main(TestException.java:8)	
```
这段代码模拟了一般的出现异常的情况。此打印信息是因为将Throwable对象的`堆栈跟踪(StackTrace)`输出至`错误输出流`,做为字段System.err的值。

#### 2、捕获和处理异常

try..catch..catch..finally

#### 3、try-with-resources结构

作用：更容易地关闭在try-catch语句块中使用的资源

使用原因：由于可能在finally中出现异常，最终导致资源未被关闭的情况。

**使用说明**

参考：http://ifeve.com/java-7%E4%B8%AD%E7%9A%84try-with-resources/

1）在java7以前，程序中使用的资源需要被明确地关闭。

```java
private static void printFile() throws IOException {
    InputStream input = null;

    try {
        input = <strong>new FileInputStream("file.txt")</strong>;

        int data = <strong>input.read()</strong>;
        while(data != -1){
            System.out.print((char) data);
            data = <strong>input.read()</strong>;
        }
    } finally {
        if(input != null){
            <strong>input.close()</strong>;
        }
    }
}
```

在上面代码中，try语句块中有3个地方能抛出异常，finally语句块中能抛出一处。

try中有异常必定会抛出，但是如果finally中close()语句关闭失败，该方法也会导致抛出异常。假使try和finally都抛出异常，那么哪个异常会根据调用栈往外传播呢？

即使try语句块中抛出的异常与异常传播更相关，最终还是finally语句块中抛出的异常会根据调用栈向外传播。(**重要)**

2）在java7中，用try-with-resource 结构这样写：

```java
private static void printFileJava7() throws IOException {
    try(FileInputStream input = new FileInputStream("file.txt")) {
        int data = input.read();
        while(data != -1){
            System.out.print((char) data);
            data = input.read();
        }
    }
}
```

注意方法中的第一行：try(FileInputStream input = new FileInputStream("file.txt")) {

这是try-with-resource 结构的用法。FileInputStream 类型变量就在try关键字后面的括号中声明。而且一个FileInputStream 类型被实例化并被赋给了这个变量。

当try语句运行结束时，FileInputStream 会被自动关闭。因为FileInputStream 实现了java中的`java.lang.AutoCloseable`接口。所有实现了这个接口的类都可以在try-with-resources结构中使用。

当try-with-resources结构中抛出一个异常，同时FileInputStreami被关闭时（调用了其close方法）也抛出一个异常，try-with-resources结构中抛出的异常会向外传播，而FileInputStreami被关闭时抛出的异常被抑制了。(**重要**：这就是与finally语句块中关闭资源相反的地方，也是try-with-resources出现的必要，*弥补了异常处理的不足之处*)

3）使用多个资源：可以在块中使用多个资源而且这些资源都能被自动地关闭。如下：

```java
private static void printFileJava7() throws IOException {

    try(  FileInputStream     input         = new FileInputStream("file.txt");
          BufferedInputStream bufferedInput = new BufferedInputStream(input)
    ) {

        int data = bufferedInput.read();
        while(data != -1){
            System.out.print((char) data);
    data = bufferedInput.read();
        }
    }
}
```

上面例子需要注意的是资源的关闭顺序，按创建逆序关闭。即首先BufferedInputStream 会被关闭，然后FileInputStream会被关闭。

4）自定义AutoCloseable实现

try-with-resources结构里不仅能够操作java内置的类，也可以在自己的类中实现java.lang.AutoCloseable接口，然后在try-with-resources结构里使用这个类。

#### 4、throw与throws

throw用在代码中，而throws放在方法或类上。

需要记住的是，throw只能抛出从`java.lang.Throwable`类继承的对象。

#### 5、实战常用

**堆栈跟踪`StackTrace`**

​	堆栈跟踪提供有关当前线程的执行历史信息（方法调用过程列表），并列出被成为在异常发生时的类和方法的名称。常用于抛出异常时调试。

一个`StackTrace常`包含信息如下：

![](D:\ztl\笔记\Java基础\关于官方文档学习笔记记录(20190222)md\01基本基础md\pictures\QQ截图20190305171715.png)

### 2、基本I/O

#### 0、IO流简介

流的定义：流是指一连串流动的字符,是以先进先出方式发送信息的通道。
按流向分：输出流：OutputStream和Writer为基类
​                  输入流：InputStream和Reader为基类

​		  输入输出的参照对象是Java程序。

按处理数据单元划分：

​	字节流：字节输入流：InputStream基类
​                      字节输出流：OutputStream基类

​               	       字节流读取的最小单位是一个字节

​        字符流：字符输入流：Reader基类
​                       字节输出流：Writer基类

​			字符流一次可以读取一个字符

（字节流是 8 位通用字节流，字符流是16位Unicode字符流）

#### 1、字节流

**定义**

程序使用*字节流*来执行8位字节的输入和输出。所有字节流类都来自 [`InputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html)和 [`OutputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html)。(抽象接口，必须使用其实现类)

**为何需要知道字节流？**

- 由于其他流类型都是基于字节流构建的，所以字节流是所有其他流类型的基础。
- 可操作任何数据类型(音频、视频、图片、文本)

**重点关注文件字节流**
由于其他种类的字节流的使用方式大致相同，主要区别在于构造方式的不同。

这里以`FileInputStream`和`FileOutputStream`为例，说明字节流的工作原理。

```java
package IO.byteStreams;

import org.junit.Test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * @Description:
 * @Date: 2019/3/7 10:27
 */
public class CopyBytes {

    /**
     * 复制输入流到输出流
     * @throws IOException
     */
    @Test
    public void copyBytes() throws IOException {

        FileInputStream in = null;
        FileOutputStream out = null;
        try {
            in = new FileInputStream("src\\IO\\file\\test.txt");
            out = new FileOutputStream("src\\IO\\file\\outTest.txt");
            int len=-1;
            byte[] bytes = new byte[1024];
            int  count=1;
            while((len=in.read(bytes))!=-1){//将字节数组作为中间对象，直到将输入流中的数据读完为止。
                out.write(bytes,0,len-1);
                System.out.println("第"+count++ +"输出："+ len+"字节");
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(out !=null){
                out.close();
            }
            if(in != null){
                in.close();
            }
        }

    }
}
```

#### 2、字符流

**定义**

字符流只能传输文本类型的数据，其价值在于：在字节流的基础上融入了编码操作。所有的字符流都来自于 `Reader`和 `Writer`。(抽象接口，必须使用其实现类)

**前言**

Java平台使用Unicode约定存储字符值。字符流 I/O自动转换为本地字符集和从本地字符集转换，即自动适应本地字符集，并且可进行国际化。总之，开发者们不用需关注编码问题。

以下是例子说明：

```java
package IO.characterStreams;

import org.junit.Test;

import java.io.*;

/**
 * @Description:
 * @Date: 2019/3/7 11:37
 */
public class CopyCharacters {
    /**
     * 复制字符输入流到字符输出流
     * @throws IOException
     */
    @Test
    public void copyCharacters() throws IOException {

        FileReader in = null;
        FileWriter out = null;
        try {
            in = new FileReader("src\\IO\\file\\test.txt");
            out = new FileWriter("src\\IO\\file\\outTest.txt");
            int len=-1;
            char[] chars = new char[1024];
            int  count=1;
            //此处FileReade的read()方法只能读取到字符数组
            while((len=in.read(chars))!=-1){
                out.write(chars,0,len-1);
                System.out.println("第"+count++ +"输出："+ len+"字符");
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(out !=null){
                out.close();
            }
            if(in != null){
                in.close();
            }
        }
    }
}
```

**面向行的 I/O**

此处要实现，需要使用到BufferedReader和PrintWriter。

一以下示例中，`BufferedReader.readLine`和`PrintWriter.println`一行输入和输出一行。

```java
/**
 * @Description:以行为单位读取和输出
 * @Date: 2019/3/7 14:09
 */
public class CopyLines {
    @Test
    public void  copyLines() throws IOException {
        BufferedReader in = null;
        PrintWriter out = null;
        try {
            in = new BufferedReader(new FileReader("src\\IO\\file\\test.txt"));
            out = new PrintWriter(new FileWriter("src\\IO\\file\\outTest-copyLines.txt"));
            String str;
            while ((str=in.readLine()) !=null ){
                out.println(str);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(out !=null){
                out.close();
            }
            if(in != null){
                in.close();
            }
        }
    }
}
```

#### 3、缓冲流

**含义**

缓冲输入流：从缓冲区的存储区读取数据，仅当缓冲区为空时才调用本机输入API。

缓冲输出流：将数据写到缓冲区，仅当缓冲区满时才调用本机输出API。

**包装非缓冲流为缓冲流**

​	BufferedInputStream && BufferedOutputStream  缓冲字节流

​	BufferedReader && BufferedWriter   缓冲字符流

**刷新缓冲流**

在关键点写出缓冲区通常是有意义的，而无需等待它填充。这称为*刷新*缓冲区。

**使用注意**

由于以上所示的4中缓冲流中的构造函数中需要传入非缓冲流对象，所以创建缓冲流是必须先创建非缓冲流。

#### 4、数据流

数据流支持基本数据类型的二进制和字符串（String）值操作。所有的数据流都实现DataInput / DataOutput接口。而常用的是其实现类DataInputStream /DataOutputStream。

以下是数据流操作的示例：

```java
package IO.dataStreams;

import IO.IO;
import org.junit.Test;

import java.io.*;

/**
 * @Description:数据流
 * @Date: 2019/3/8 13:51
 */
public class dataStreams {

    static final String dataFile = "src\\IO\\file\\invoicedata.txt";

    static final double[] prices = { 19.99, 9.99, 15.99, 3.99, 4.99 };
    static final int[] units = { 12, 8, 13, 29, 50 };
    static final String[] descs = {
            "Java T-shirt",
            "Java Mug",
            "Duke Juggling Dolls",
            "Java Pin",
            "Java Key Chain"
    };

    /**
     * 数据输出流测试
     * @throws IOException
     */
    @Test
    public void testDataOutputStrean() throws IOException {
        try(DataOutputStream out = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(dataFile)));
        ){
            for(int i=0;i<prices.length;i++){
                out.writeDouble(prices[i]);//输出api
                out.writeInt(units[i]);
                out.writeUTF(descs[i]);
            }
        }
    }

    /**
     * 数据输入流测试
     * @throws IOException
     */
    @Test
    public void testDataInputStrean() throws IOException {
        try(DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(dataFile)));
        ){
            double price;
            int unti;
            String descs;
            while (true){
                System.out.format("%.2f "+" %d "+" %s%n",in.readDouble(),in.readInt(),in.readUTF());//输入api
            }
        }catch (EOFException e){
            /*
            *EOFException表示在输入期间意外到达文件末尾或流末尾的信号。
		   *此异常主要由数据输入流用于信号流的结束。
		   */
        }
    }
}
```

以上示例，需要注意的是，数据流输入操作是通过捕获EOFException来检测文件结束。DataInput方法的所有实现都使用EOFException而不是返回值。

#### 5、对象流

对象流类：ObjectInputStream && ObjectOutStream

对象流的基础是数据流，对象流接口ObjectInput /ObejctOutput 是数据流接口DataInput /DataOutput的子接口，所以，对象流能操作对象和基本数据类型。

#### 6、字节流和字符流的相互转换（后缀区分）

从字节流到字符流：InputStreamReader、OutputStreamWriter类可以实现。

从字符流到字节流：可以从字符流中获取char[]数组，转换为String，然后调用String的API函数getBytes() 获取到byte[]，然后就可以通过ByteArrayInputStream、ByteArrayOutputStream来实现到字节流的转换。

### 3、并发性

#### 1、进程和线程

**前言**

在并发编程中，有两个基本的执行单元：进程和线程。在Java开发中，并发编程主要涉及线程，但是，进程也同样的重要。

具体多个处理器或者多个执行核心的处理器的计算机系统，极大增强了系统并发执行能力。即使在只有单处理器或单执行核心的处理器上，也可以实现并发。

**进程**

进程具有独立的(官方称：自包含)执行环境，意味着每个进程都包含自己私有化的完整的运行时资源集，特别是拥有自己的内存空间。

进程通常被认为是程序或应用程序的同义词。但是事实上，单个应用程序可能是多组进程互相协作的集合。此外，不得不提*进程间通信IPC*，IPC支持在同一系统的进程间通信，也可以在不同系统间。

Java虚拟机的大多数实现都是作为单个进程进行。

**线程**

线程是存在于进程里的概念，每个进行至少拥有一个线程。进行和线程都提供执行环境，但创建线程比创建进程开销小得多。

线程有时被称为轻量级进程。

多线程执行是Java平台的基本特性。

#### 2、线程对象

##### 定义与启动线程

**方法一：继承Thread类，覆盖run方法**

示例如下：

```java
//1):定义一个类A继承于java.lang.Thread类.
class MusicThread extends Thread{
	//2):在A类中覆盖Thread类中的run方法.
	public void run() {
		//3):在run方法中编写需要执行的操作
		for(int i = 0; i < 50; i ++){
			System.out.println("播放音乐"+i);
		}
	}
}

public class ExtendsThreadDemo {
	public static void main(String[] args) {
        for(int j = 0; j < 50; j ++){
            System.out.println("运行游戏"+j);
            if(j == 10){
                //4):在main方法(线程)中,创建线程对象,并启动线程.
                MusicThread music = new MusicThread();
                music.start();
            }
        }
	}
}
```

以上例子中，需要注意得是，在开启线程时，不能用music.run(),这样意味着没有开启新的线程而是普通调用而已，所以注意使用start来启动线程。

**方法二：实现Runnale接口，编写run方法**

示例如下：

~~~java
//1):定义一个类A实现于java.lang.Runnable接口,注意A类不是线程类.
class MusicImplements implements Runnable{
	//2):在A类中覆盖Runnable接口中的run方法.
	public void run() {
		//3):在run方法中编写需要执行的操作
		for(int i = 0; i < 50; i ++){
			System.out.println("播放音乐"+i);
		}
		
	}
}
 
public class ImplementsRunnableDemo {
	public static void main(String[] args) {
		for(int j = 0; j < 50; j ++){
			System.out.println("运行游戏"+j);
			if(j == 10){
			    //4):在main方法(线程)中,创建线程对象,并启动线程
				MusicImplements mi = new MusicImplements();
				Thread t = new Thread(mi);
				t.start();
			}
		}
	}
}
~~~

以上例子中，实现Runnable接口实际上是为了构造Thread。

**继承与实现开启线程的优劣**

继承方式:
​                1):从设计上分析，Java中类是单继承的,如果继承了Thread了,该类就不能再有其他的直接父类了.
​                2):从操作上分析,继承方式更简单,获取线程名字也简单.(操作上,更简单)
​                3):从多线程共享同一个资源上分析,继承方式不能做到.

实现方式:
​                1):从设计上分析，Java中类可实现多接口,该类还可以继承其他类,并且还可以实现其他接口，设计更为合理.
​                2):从操作上分析,实现方式稍微复杂点,获取线程名字也比较复杂,得使用Thread.currentThread()来获取当前线程的引用.

​		 3):从多线程共享同一个资源上分析,实现方式可以做到(是否共享同一个资源).

##### 暂停执行与睡眠

`Thread.sleep`导致当前线程暂停执行指定的时间段。

##### 中断interrupt

中断方式：请求另外一个线程不要再执行了。(非强制性)

为了使中断机制正常执行，收到中断指示的线程必须支持自己来主动中断。这里可以这样理解：假如家长叮嘱孩子要注意身体，孩子会参考父母的意见，但是是否要注意身体由孩子自主决定。

关于中断的详细介绍：可参考： [JAVA多线程之中断机制(如何处理中断？)](https://www.cnblogs.com/hapjin/p/5450779.html)

##### 加盟Join

参考：[java 线程方法join的简单总结](https://www.cnblogs.com/lcplcpjava/p/6896904.html)

作用：在A线程中调用B线程的join()方法，意味着此时线程由并行改为了串行，即A线程暂停执行，等到B执行完毕A才继续执行。

另外，join()可传入时间参数，如join(10)表示A线程会等待B线程执行10毫秒，10毫秒过去后，A线程与B线程并行执行。

附源码：

~~~java
public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
~~~

分析：

​	从以上源码可以看出，当A线程调用B线程的join()方法后，相当于调用了一个wait()等待函数，而此时B线程在执行，当B执行完毕（或等待时间结束），B线程会自动调用自身的notifyAll()方法唤醒A线程，从而达到同步(串行)的目的。

#### 3、同步Synchronization

**线程通信存在的问题**

线程之间通过共享字段或对象引用进行通信。但可能出现两种错误：线程干扰和内存一致性错误。防止这些错误的工具就是同步。

线程干扰：当多个线程操作同一对象时，存在互相覆盖干扰的问题。（如：count++、count--）

内存一致性错误：不同线程看到的内存中的同一份数据却有不同的“视图”。意味着不能保证线程A对对象的操作对于线程B是可见的。

**同步方法与同步代码块**

参考：[同步方法和同步代码块的区别](https://blog.csdn.net/qq_18433441/article/details/78218167)

1、同步方法 ：即有synchronized关键字修饰的方法。 

​    由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 

​    内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

​    代码如：  public synchronized void save(){}

 2、同步代码块 ：即有synchronized关键字修饰的语句块。 

​    被该关键字修饰的语句块会自动被加上内置锁，从而实现同步

​    代码如：  synchronized(object){}

​    注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 

​    通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

   注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类

**内在锁定和同步**

同步是基于内部锁(或称监视器锁)。内部锁在同步中有两个作用：强制对对象状态进行独占访问；建立对可见性至关重要的先发生关系（即线程间对共享内存的可见性，为了杜绝内存一致性错误）。

#### 4、活跃性

并发应用程序及时执行的能力被称为其活跃性。活跃性大致有三个问题：如下所示。

**死锁**

*死锁*描述了两个或多个线程永远被阻塞，等待彼此的情况。

**饥饿**

饥饿是一种线程长期不能访问共享资源的情况。当某些’‘贪婪’‘线程长期占用资源时就会出现这种情况。

**活锁**

线程通常用于响应另一个线程的操作。如果另一个线程的操作也是对另一个线程的操作的响应，则可能导致*活锁。*与死锁一样，活锁线程无法取得进一步进展。但是，线程没有被阻塞 - 他们只是太忙于相互回应以恢复工作。如走廊里互相谦让的人反而导致互相阻止。

#### 5、高级并发对象

**前言**

在之前了解的是Java平台的一部分的低级API，这些API适合非常基本的任务。但跟高级的任务需要更加高级的构建块。

在Java5.0中引入了一些高级并发功能。大多数这些功能都在java.util.concurrent包中实现。另外，在Java Collections Framework中还有新的并发数据结构。

此部分大致有以下几点内容：

- 锁定对象Lock Objects—支持锁定习惯用法，简化了许多并发应用程序；
- 执行程序Executors—定义了用于启动和管理线程的API。提供`java.util.concurrent`适用于大规模应用程序的线程池管理；
- 并发集合—使管理大量数据更加容易，并且可以大大减少同步需求；
- 原子变量—具有最小化同步并有助于避免内存一致性错误的功能；
- ThreadLocalRandom（在JDK7中）提供了从多个线程有效生成伪随机数。

##### 锁对象

对比: 

​	同步代码依赖于简单的可重入锁定，这种锁虽易于使用，但是限制多。java.util.concurrent.locks包装了支持更加复杂的方式。

特点：

​	Lock对象的工作方式与同步代码使用的隐式锁非常相似。与隐式锁一样，一次一个线程只能拥有一个Lock对象。Lock对象还可通过wait/notify来关联Condition对像支持机制。

优点：

未完，待续...

### 4、平台环境

应用程序在平台环境中运行，改平台环境一般包括：底层操作系统，Java虚拟机，类库以及启动应用程序时提供的各种配置数据。

#### 1、配置工具Configuration Utilities

 **Properties**：java.util.Properties

使用PropertiesReader对象获取resource.properties。

**命令行参数**

#### 2、系统工具System Utilities

#### 3、PATH and CLASSPATH

### 5、正则表达式

仅仅过了一遍基础，暂时到此，实战中加强。

































































