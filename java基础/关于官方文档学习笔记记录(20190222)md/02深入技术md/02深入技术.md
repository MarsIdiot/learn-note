# 深入技术

参考:https://docs.oracle.com/javase/tutorial/tutorialLearningPaths.html

## 一、集合

### == 与 equals

**==** 

***地址***是不是相等。即，判断两个对象是不是同一个对象(***基本数据类型==比较的是值，引用数据类型==比较的是内存地址***)。

**equals()** 

它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

**说明：**

- ***String 中的 equals 方法是被重写过的***，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 

### hashCode 与 equals

**HashSet插入对象过程**

1)计算对象hashCode值

2)比较hashCode值是否重复

3）情况一:不重复。执行操作操作。

4）情况二：重复。equals比较值是否相同。若相同，不进行插入操作；不同，则重新进行计算hashCode值，重复以上操作。

**hashCode值作用**

hashCode值用来确定***对象在哈希表中的索引位置***。hashCode值是根据对象计算出来的散列码(或称哈希码)，是一个int整数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的***检索***出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）。

**hashCode如何提供检索速度**

当hashCode值相同时表示对象相同，则减少了 equals 的次数，相应就大大提高了执行速度。

**任何类都包含hashCode() 函数**

hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。

**为什么在重写equals方法的同时，必须重写hashCode方法？**

如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。

~~~java
默认情况下，hashCode方法是将对象的存储地址进行映射。
而如下所示代码:将p1放到hashMap中会生存一个哈希值，当执行hashMap.get(new People("Jack", 12))时,new People("Jack", 12)的地址与People p1 = new People("Jack", 12);的地址不一致，所以由于默认hashCode将对象的地址进行映射，则存和取得哈希值不一样。所以需要重写hashCode0()方法。


People p1 = new People("Jack", 12);
System.out.println(p1.hashCode());//p1哈希值

HashMap<People, Integer> hashMap = new HashMap<People, Integer>();
hashMap.put(p1, 1);

System.out.println(hashMap.get(new People("Jack", 12)));//不重写输出null;重写输出1
~~~

**设计hashCode()时最重要的因素**

***无论何时，对同一个对象调用hashCode()都应该产生同样的值***。如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码。





## 二、Lambad表达式



## 二一、聚合操作



## 三、JAR文件打包



## 四、国际化



## 五、反射



## 六、安全性







## 八、扩展机制-自定义API



## 九、泛型-对类型系统的增强





















