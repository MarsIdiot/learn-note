# 深入技术

参考:https://docs.oracle.com/javase/tutorial/tutorialLearningPaths.html

## 一、集合collection

### 0、概览

容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。

![.\pictures\collection.png](.\pictures\collection.png)

### 1. Set

- TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
- HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
- LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。

### 2. List

- ArrayList：基于动态数组实现，支持随机访问。
- Vector：和 ArrayList 类似，但它是线程安全的。
- LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。

### 3. Queue

- LinkedList：可以用它来实现双向队列。
- PriorityQueue：基于堆结构实现，可以用它来实现优先队列。



### 20、其他重要点

#### ArrayList和LinkedList的区别

|              | ArrayList                                             | LinkedList               |
| ------------ | ----------------------------------------------------- | ------------------------ |
| 组成         | 动态数组                                              | 双向链表                 |
| 是否支持下标 | Ｙ  支持快速随机访问                                  | N                        |
| 查询         | 快                                                    | 慢   蛮力法遍历          |
| 修改、删除   | 慢   需要进行大量数组移动操作（导致大量数组复制操作） | 快  只需修改前后指针即可 |
| 是否浪费空间 | Y  随时需要探测数组容量然后扩容                       | N  链表节点动态添加即可  |

####  foreach内不能执行修改

以ArrayList为例。说明如下：

ArrayList是线程不安全的，***在被修改后再继续迭代就报错***。***modCount***是指ArrayList的修改次数，每次add或remove都会自增，当迭代时，就是将这个modCount暂存在expectedModCount中，每次获取下一个元素时，检查下修改次数是否有变动，有变动则不再继续迭代，而是抛出错误ConcurrentModificationException。这样就强制要求在迭代时不能进行remove/add操作，而foreach会编译成迭代，所以foreach时也不能进行remove/add操作。

![.\pictures\foreach不能执行修改操作.png](.\pictures\foreach不能执行修改操作.png)

## 二、Map

### 0-1、== 与 equals

**==** 

***地址***是不是相等。即，判断两个对象是不是同一个对象(***基本数据类型==比较的是值，引用数据类型==比较的是内存地址***)。

**equals()** 

它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

**说明：**

- ***String 中的 equals 方法是被重写过的***，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 

### 0-2、hashCode 与 equals

**HashSet插入对象过程**

1)计算对象hashCode值

2)比较hashCode值是否重复

3）情况一:不重复。执行操作操作。

4）情况二：重复。equals比较值是否相同。若相同，不进行插入操作；不同，则重新进行计算hashCode值，重复以上操作。

**hashCode值作用**

hashCode值用来确定***对象在哈希表中的索引位置***。hashCode值是根据对象计算出来的散列码(或称哈希码)，是一个int整数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的***检索***出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）。

**hashCode如何提供检索速度**

当hashCode值相同时表示对象相同，则减少了 equals 的次数，相应就大大提高了执行速度。

**任何类都包含hashCode() 函数**

hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。

**为什么在重写equals方法的同时，必须重写hashCode方法？**

如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。

```java
默认情况下，hashCode方法是将对象的存储地址进行映射。
而如下所示代码:将p1放到hashMap中会生存一个哈希值，当执行hashMap.get(new People("Jack", 12))时,new People("Jack", 12)的地址与People p1 = new People("Jack", 12);的地址不一致，所以由于默认hashCode将对象的地址进行映射，则存和取得哈希值不一样。所以需要重写hashCode0()方法。


People p1 = new People("Jack", 12);
System.out.println(p1.hashCode());//p1哈希值

HashMap<People, Integer> hashMap = new HashMap<People, Integer>();
hashMap.put(p1, 1);

System.out.println(hashMap.get(new People("Jack", 12)));//不重写输出null;重写输出1
```

**设计hashCode()时最重要的因素**

***无论何时，对同一个对象调用hashCode()都应该产生同样的值***。如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码。

### 0、概览

![.\pictures\map.png](.\pictures\map.png)

- TreeMap：基于红黑树实现。
- HashMap：基于哈希表实现。
- Hashtable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 Hashtable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
- LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

1、

## 三、Lambad表达式



## 四、聚合操作



## 五、JAR文件打包



## 六、国际化



## 七、反射



## 八、安全性







## 九、扩展机制-自定义API



## 十、泛型-对类型系统的增强





















