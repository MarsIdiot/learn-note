# 深入技术

参考:https://docs.oracle.com/javase/tutorial/tutorialLearningPaths.html

## 一、集合collection

### 0、概览

容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。

![.\pictures\collection.png](.\pictures\collection.png)

### 1. Set

- TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
- HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
- LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。

### 2. List

- ArrayList：基于动态数组实现，支持随机访问。
- Vector：和 ArrayList 类似，但它是线程安全的。
- LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。

### 3. Queue

- LinkedList：可以用它来实现双向队列。
- PriorityQueue：基于堆结构实现，可以用它来实现优先队列。



### 20、其他重要点

#### ArrayList和LinkedList的区别

|              | ArrayList                                             | LinkedList               |
| ------------ | ----------------------------------------------------- | ------------------------ |
| 组成         | 动态数组                                              | 双向链表                 |
| 是否支持下标 | Ｙ  支持快速随机访问                                  | N                        |
| 查询         | 快                                                    | 慢   蛮力法遍历          |
| 修改、删除   | 慢   需要进行大量数组移动操作（导致大量数组复制操作） | 快  只需修改前后指针即可 |
| 是否浪费空间 | Y  随时需要探测数组容量然后扩容                       | N  链表节点动态添加即可  |

####  foreach内不能执行修改

以ArrayList为例。说明如下：

ArrayList是线程不安全的，***在被修改后再继续迭代就报错***。***modCount***是指ArrayList的修改次数，每次add或remove都会自增，当迭代时，就是将这个modCount暂存在expectedModCount中，每次获取下一个元素时，检查下修改次数是否有变动，有变动则不再继续迭代，而是抛出错误ConcurrentModificationException。这样就强制要求在迭代时不能进行remove/add操作，而foreach会编译成迭代，所以foreach时也不能进行remove/add操作。

![.\pictures\foreach不能执行修改操作.png](.\pictures\foreach不能执行修改操作.png)

## 二、Map

### 0-1、== 与 equals

**==** 

***地址***是不是相等。即，判断两个对象是不是同一个对象(***基本数据类型==比较的是值，引用数据类型==比较的是内存地址***)。

**equals()** 

它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

**说明：**

- ***String 中的 equals 方法是被重写过的***，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 

### 0-2、hashCode 与 equals

**HashSet插入对象过程**

1)计算对象hashCode值

2)比较hashCode值是否重复

3）情况一:不重复。执行操作操作。

4）情况二：重复。equals比较值是否相同。若相同，不进行插入操作；不同，则重新进行计算hashCode值，重复以上操作。

**hashCode值作用**

hashCode值用来确定***对象在哈希表中的索引位置***。hashCode值是根据对象计算出来的散列码(或称哈希码)，是一个int整数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的***检索***出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）。

**hashCode如何提供检索速度**

当hashCode值相同时表示对象相同，则减少了 equals 的次数，相应就大大提高了执行速度。

**任何类都包含hashCode() 函数**

hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。

**为什么在重写equals方法的同时，必须重写hashCode方法？**

如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。

```java
默认情况下，hashCode方法是将对象的存储地址进行映射。
而如下所示代码:将p1放到hashMap中会生存一个哈希值，当执行hashMap.get(new People("Jack", 12))时,new People("Jack", 12)的地址与People p1 = new People("Jack", 12);的地址不一致，所以由于默认hashCode将对象的地址进行映射，则存和取得哈希值不一样。所以需要重写hashCode0()方法。


People p1 = new People("Jack", 12);
System.out.println(p1.hashCode());//p1哈希值

HashMap<People, Integer> hashMap = new HashMap<People, Integer>();
hashMap.put(p1, 1);

System.out.println(hashMap.get(new People("Jack", 12)));//不重写输出null;重写输出1
```

**设计hashCode()时最重要的因素**

***无论何时，对同一个对象调用hashCode()都应该产生同样的值***。如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码。

### 0、概览

![.\pictures\map.png](.\pictures\map.png)

- TreeMap：基于红黑树实现。
- HashMap：基于哈希表实现。
- Hashtable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 Hashtable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
- LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

### 1、HashMap 

#### 数据结构

数据模型

![.\pictures\hash表数据结构.png](.\pictures\hash表数据结构.png)

对hashMap感性认知：

![.\pictures\hashmap结构实例图.png](.\pictures\hashmap结构实例图.png)



#### put和get原理

两条结合参考：

https://www.jianshu.com/p/7126d65e49a5

https://blog.csdn.net/linsongbin1/article/details/54667453

**概述**

JAVA中当使用HashMap的put方法的时候,有两个问题要解决：

1、长度为16的数组中，元素存储在哪个位置

2、如果key出现hash冲突,如何解决

**第一个问题**

HashMap 是使用下面的算法来计算元素的存放位置的。

~~~java
int hash = hash(key);
int i = indexFor(hash, table.length);//根据除余法计算下标  hash/table.length的余数
~~~

首先先hash,之后结合数组的长度进行一个**&**操作得到得到数组的下标。

**第二个问题**

则利用Entry类的**next**变量来实现链表,把***最新的元素放到链表头***,旧的数据则被最新的元素的next变量引用着。

举个例子,假设元素Entry<"1","1">通过hash算法算出存到下标为0的位置上,后面又添加一个Entry<"2","2">,

假设Entry<"2","2">通过hash算法算出也需要存到下标为0的数组中,那么此时链表是下面这个样子的:

Entry<”2”,”2”> –> Entry<”1”,”1”>

也即是说,当key出现hash冲突的时候*,**链表中的第一个元素都是后面最新添加进来的那个,之前的则被next变量引用着***。虽然这里是插入的动作,但是由于使用了链表,所以无需像数组的插入那样,进行数组拷贝。

**HashMap get操作**

这个操作的原理就比较简单,只需要根据key的hashcode算出元素在数组中的下标,之后遍历Entry对象链表,直到找到元素为止。

~~~java
int hash = (key == null) ? 0 : hash(key);//计算key的hashcode
for (Entry e = table[indexFor(hash, table.length)];e != null;e = e.next) {//遍历Entry对象链表
	Object k;
	if (e.hash == hash &&
        ((k = e.key) == key || (key != null && key.equals(k)))//哈希值相同且key相同
       )
	   return e;
}
'值得一提的是，为什么需要遍历链表?并且除了比较hashCode还要比较key'
因为一个元素放在同一链表中只是因为其hashCode根据除余法计算出的值(即数组下标)相等，根据这个下标是不能确定元素在链表中的具体位置，所以需要遍历。
另外，在遍历链表时，可能存在哈希值相同的元素，此时还需要进一步比较key的值。所以有了代码中的if条件判断。
~~~

这里有两个注意点:

1、这里利用key的hashcode方法和equals方法,所以在使用HashMap的时候,如果***使用对象作为key***,最好覆写key的hashcode和equals方法。

不然可能出put到HashMap的时候,成功了,但是get的时候却没有找到数据。

补充说明:如果使用对象作为key，原来的hashCode()计算hash码时,会因为put时的对象key和get时的对象key指向的地址不同而导致哈希值不同。

2、如果key hash冲突太多,会造成链表过长,在链表中查找元素的时候,会比较慢。

**hash冲突后优化方案**

如果出现了大量hash冲突,那么遍历链表的时候,会比较慢。JDK 1.8里面，当链表的长度大于阀值(默认为8)的时候,会使用***红黑树***来存储数据,以便加快key的查询速度。

**总结**

HashMap使用了**数组+链表**的方案,做到了读取快,插入快的目的,但是HashMap还是一些使用上的问题的:

1、线程不安全

2、当容量不够时,会进行rehash的流程,非常耗资源

#### 面试问题

参考：[https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/](https://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/)

##### hashMap特点，什么时候用，举例说明

基于Map接口实现；链表数组，加入 红黑树（JDK 8）；无序性；允许null键/值；非同步。

存储键值对时使用。HashMap存储着Entry(hash, key, value, next)对象。

##### HashMap的工作原理

通过hash的方法，通过put和get存储和获取对象。

1）hash及位置计算

2）碰撞时拉链法处理

3）扩容

##### equals()和hashCode()的作用

equals():比较key值

hashCode():计算key的hash码

##### hash实现原理？为什么

https://www.hollischuang.com/archives/2091

在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：在对hashCode()计算hash时具体实现是这样的：

![.\pictures\hash过程.png](.\pictures\hash过程.png)

```java
static final int hash(Object key) {    
    int h;    
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。

再进行取模。

~~~java
(n - 1) & hash
~~~

##### put原理

大致思路如下:

1)计算key的hash值，然后计算在桶的位置index；

2）如果不碰撞，直接放入桶；

3）如果碰撞，放到链表中。若节点key相同，则更新value，否则直接放入链表头；

4）如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；

5）如果bucket满了(超过load factor*current capacity)，就要resize；

##### get原理

大致思路如下:第一步同put得到位置index

1) 取链表第一个节点，直接命中；

2）否则，遍历链表或树查找(条件：hash值相同且key相同)

##### HashMap扩容

当loadfactor*capacity大于存入大小，扩容为原来大小的2倍。之后重新计算index，把节点再放到新的bucket中。

### 2、TreeMap

### 3、Hashtable

除了不允许 null 并且同步，与hashMap 几乎一样。

与 HashMap 的比较

- Hashtable 使用 synchronized 来进行同步。
- HashMap 可以插入键为 null 的 Entry。
- HashMap 的迭代器是 fail-fast 迭代器。（ fail-safe）
- HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。

### 4、LinkedHashMap

## 三、Lambad表达式



## 四、聚合操作即



## 五、JAR文件打包



## 六、国际化



## 七、反射



## 八、安全性





## 九、扩展机制-自定义API



## 十、泛型-对类型系统的增强





















 