# 深入技术

参考:https://docs.oracle.com/javase/tutorial/tutorialLearningPaths.html

## 一、集合collection

### 0、概览

容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。

![.\pictures\collection.png](.\pictures\collection.png)

### 1. Set

- TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
- HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
- LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。

### 2. List

- ArrayList：基于动态数组实现，支持随机访问。
- Vector：和 ArrayList 类似，但它是线程安全的。
- LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。

### 3. Queue

- LinkedList：可以用它来实现双向队列。
- PriorityQueue：基于堆结构实现，可以用它来实现优先队列。



### 20、其他重要点

#### ArrayList和LinkedList的区别

|              | ArrayList                                             | LinkedList               |
| ------------ | ----------------------------------------------------- | ------------------------ |
| 组成         | 动态数组                                              | 双向链表                 |
| 是否支持下标 | Ｙ  支持快速随机访问                                  | N                        |
| 查询         | 快                                                    | 慢   蛮力法遍历          |
| 修改、删除   | 慢   需要进行大量数组移动操作（导致大量数组复制操作） | 快  只需修改前后指针即可 |
| 是否浪费空间 | Y  随时需要探测数组容量然后扩容                       | N  链表节点动态添加即可  |

####  foreach内不能执行修改

以ArrayList为例。说明如下：

ArrayList是线程不安全的，***在被修改后再继续迭代就报错***。***modCount***是指ArrayList的修改次数，每次add或remove都会自增，当迭代时，就是将这个modCount暂存在expectedModCount中，每次获取下一个元素时，检查下修改次数是否有变动，有变动则不再继续迭代，而是抛出错误ConcurrentModificationException。这样就强制要求在迭代时不能进行remove/add操作，而foreach会编译成迭代，所以foreach时也不能进行remove/add操作。

![.\pictures\foreach不能执行修改操作.png](.\pictures\foreach不能执行修改操作.png)

## 二、Map

### 0-1、== 与 equals

**==** 

***地址***是不是相等。即，判断两个对象是不是同一个对象(***基本数据类型==比较的是值，引用数据类型==比较的是内存地址***)。

**equals()** 

它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

**说明：**

- ***String 中的 equals 方法是被重写过的***，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 

### 0-2、hashCode 与 equals

**HashSet插入对象过程**

1)计算对象hashCode值

2)比较hashCode值是否重复

3）情况一:不重复。执行操作操作。

4）情况二：重复。equals比较值是否相同。若相同，不进行插入操作；不同，则重新进行计算hashCode值，重复以上操作。

**hashCode值作用**

hashCode值用来确定***对象在哈希表中的索引位置***。hashCode值是根据对象计算出来的散列码(或称哈希码)，是一个int整数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的***检索***出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）。

**hashCode如何提供检索速度**

当hashCode值相同时表示对象相同，则减少了 equals 的次数，相应就大大提高了执行速度。

**任何类都包含hashCode() 函数**

hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。

**为什么在重写equals方法的同时，必须重写hashCode方法？**

如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。

```java
默认情况下，hashCode方法是将对象的存储地址进行映射。
而如下所示代码:将p1放到hashMap中会生存一个哈希值，当执行hashMap.get(new People("Jack", 12))时,new People("Jack", 12)的地址与People p1 = new People("Jack", 12);的地址不一致，所以由于默认hashCode将对象的地址进行映射，则存和取得哈希值不一样。所以需要重写hashCode0()方法。


People p1 = new People("Jack", 12);
System.out.println(p1.hashCode());//p1哈希值

HashMap<People, Integer> hashMap = new HashMap<People, Integer>();
hashMap.put(p1, 1);

System.out.println(hashMap.get(new People("Jack", 12)));//不重写输出null;重写输出1
```

**设计hashCode()时最重要的因素**

***无论何时，对同一个对象调用hashCode()都应该产生同样的值***。如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码。

### 0、概览

![.\pictures\map.png](.\pictures\map.png)

- TreeMap：基于红黑树实现。
- HashMap：基于哈希表实现。
- Hashtable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 Hashtable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
- LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

### 1、HashMap 

#### 数据结构

数据模型

![.\pictures\hash表数据结构.png](.\pictures\hash表数据结构.png)

对hashMap感性认知：

![.\pictures\hashmap结构实例图.png](.\pictures\hashmap结构实例图.png)



#### put和get原理

两条结合参考：

https://www.jianshu.com/p/7126d65e49a5

https://blog.csdn.net/linsongbin1/article/details/54667453

**概述**

JAVA中当使用HashMap的put方法的时候,有两个问题要解决：

1、长度为16的数组中，元素存储在哪个位置

2、如果key出现hash冲突,如何解决

**第一个问题**

HashMap 是使用下面的算法来计算元素的存放位置的。

~~~java
int hash = hash(key);
int i = indexFor(hash, table.length);//根据除余法计算下标  hash/table.length的余数
~~~

首先先hash,之后结合数组的长度进行一个**&**操作得到得到数组的下标。

**第二个问题**

则利用Entry类的**next**变量来实现链表,把***最新的元素放到链表头***,旧的数据则被最新的元素的next变量引用着。

举个例子,假设元素Entry<"1","1">通过hash算法算出存到下标为0的位置上,后面又添加一个Entry<"2","2">,

假设Entry<"2","2">通过hash算法算出也需要存到下标为0的数组中,那么此时链表是下面这个样子的:

Entry<”2”,”2”> –> Entry<”1”,”1”>

也即是说,当key出现hash冲突的时候*,**链表中的第一个元素都是后面最新添加进来的那个,之前的则被next变量引用着***。虽然这里是插入的动作,但是由于使用了链表,所以无需像数组的插入那样,进行数组拷贝。

**HashMap get操作**

这个操作的原理就比较简单,只需要根据key的hashcode算出元素在数组中的下标,之后遍历Entry对象链表,直到找到元素为止。

~~~java
int hash = (key == null) ? 0 : hash(key);//计算key的hashcode
for (Entry e = table[indexFor(hash, table.length)];e != null;e = e.next) {//遍历Entry对象链表
	Object k;
	if (e.hash == hash &&
        ((k = e.key) == key || (key != null && key.equals(k)))//哈希值相同且key相同
       )
	   return e;
}
'值得一提的是，为什么需要遍历链表?并且除了比较hashCode还要比较key'
因为一个元素放在同一链表中只是因为其hashCode根据除余法计算出的值(即数组下标)相等，根据这个下标是不能确定元素在链表中的具体位置，所以需要遍历。
另外，在遍历链表时，可能存在哈希值相同的元素，此时还需要进一步比较key的值。所以有了代码中的if条件判断。
~~~

这里有两个注意点:

1、这里利用key的hashcode方法和equals方法,所以在使用HashMap的时候,如果***使用对象作为key***,最好覆写key的hashcode和equals方法。

不然可能出put到HashMap的时候,成功了,但是get的时候却没有找到数据。

补充说明:如果使用对象作为key，原来的hashCode()计算hash码时,会因为put时的对象key和get时的对象key指向的地址不同而导致哈希值不同。

2、如果key hash冲突太多,会造成链表过长,在链表中查找元素的时候,会比较慢。

**hash冲突后优化方案**

如果出现了大量hash冲突,那么遍历链表的时候,会比较慢。JDK 1.8里面，当链表的长度大于阀值(默认为8)的时候,会使用***红黑树***来存储数据,以便加快key的查询速度。

**总结**

HashMap使用了**数组+链表**的方案,做到了读取快,插入快的目的,但是HashMap还是一些使用上的问题的:

1、线程不安全

2、当容量不够时,会进行rehash的流程,非常耗资源

#### 面试问题

参考1：[https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/](https://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/)

参考2：https://www.jianshu.com/p/75adf47958a7

##### hashMap特点，什么时候用，举例说明

基于Map接口实现；链表数组，加入 红黑树（JDK 8）；无序性；允许null键/值；非同步。

存储键值对时使用。HashMap存储着Entry(hash, key, value, next)对象。

##### HashMap的工作原理

HashMap 底层是 ***hash 数组***和***单向链表***实现，数组中的每个元素都是**链表**，由 **Node 内部类（实现 Map.Entry<K,V>接口）**实现，HashMap 通过 put & get 方法存储和获取。

1）hash及位置计算

2）碰撞时拉链法处理

3）扩容

##### equals()和hashCode()的作用

equals():比较key值

hashCode():计算key的hash码

##### hash实现原理？为什么

https://www.hollischuang.com/archives/2091

在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：在对hashCode()计算hash时具体实现是这样的：

![.\pictures\hash过程.png](.\pictures\hash过程.png)

```java
static final int hash(Object key) {    
    int h;    
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。

再进行取模。

~~~java
(n - 1) & hash
~~~

##### put原理

大致思路如下:

1)计算key的hash值，然后计算在桶的位置index；

2）如果不碰撞，直接放入桶；

3）如果碰撞，放到链表中。若节点key相同，则更新value，否则直接放入链表头；

4）如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；

5）如果bucket满了(超过load factor*current capacity)，就要resize；

##### get原理

大致思路如下:第一步同put得到位置index

1) 取链表第一个节点，直接命中；

2）否则，遍历链表或树查找(条件：hash值相同且key相同)

##### HashMap扩容

当loadfactor*capacity大于存入大小，扩容为原来大小的2倍。之后重新计算index，把节点再放到新的buckets中。

##### HashMap 的长度为什么是2的幂次方

计算机里面位运算是基本运算，位运算的效率是远远高于取余%运算的。 

举个例子：2^n转换成二进制就是1+n个0，减1之后就是0+n个1，如16 -> 10000，15 -> 01111

那么根据&位运算的规则，都为1(真)时，才为1，那0≤运算后的结果≤15，假设h <= 15，那么运算后的结果就是h本身，h >15，运算后的结果就是最后四位二进制做&运算后的值，最终，就是%运算后的余数。

当容量一定是2^n时，h & (length - 1) == h % length。

总结：容量为2^n的好处在于，用&运算可以达到%运算的效果。

​		当h <= length - 1时，h & (length - 1)=h;

​		当h > length - 1时，h & (length - 1)= h最后n位二进制;

​		所以，无论如何计算出的都是其余数。

### 2、TreeMap

### 3、Hashtable

除了不允许 null 并且同步，与hashMap 几乎一样。

与 HashMap 的比较

- Hashtable 使用 synchronized 来进行同步。
- HashMap 可以插入键为 null 的 Entry。
- HashMap 的迭代器是 fail-fast 迭代器。（ fail-safe）
- HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。

### 4、LinkedHashMap

### 5、ConcurrentHashMap

与HashMap对比：

​	实现上类似，最主要的差别是ConcurrentHashMap 采用了分段锁Segment，每个分段多维护着几个桶(HashEntry)，多个线程可以访问不同分段锁上的桶，从而使其并发度更高（并发度就是Segment的个数）。

### 6、总结

|              | HashMap                         | HashTable      | TreeMap | LinkedHashMap |
| ------------ | ------------------------------- | -------------- | ------- | ------------- |
| 数据结构     | 哈希表(**链表散列：数组+链表**) | 哈希表         | 红黑树  | 哈希表+链表   |
| 线程安全     | N                               | Y synchronized |         | N             |
| 允许键为null | 允许                            | 不允许         |         |               |
| 有序性       | 无序                            | 无序           | 无序    | 有序          |

## 三、并发

### 基础面试

参看：[Java 并发基础常见面试题总结](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md)

#### 1、什么是线程和进程

进程：是程序的一次执行过程，是***系统运行程序的基本单位***，因此进程是动态的。系统运行程序是一个进程从创建，到运行到消亡的过程。

线程：比进程更小的执行单位。一个进程包含多个线程。多个线程共享进程的***堆*** 和***方法区***资源，但线程拥有自己的***程序计数器***、***虚拟机栈***和***本地方法栈***。所以系统在产生一个线程或线程间切换时，负担比进程小得多，因此线程被称为**轻量级进程**。

栗子说明：在java中，当我们启动main函数时其实启动了一个JVM进程，而main函数所在得线程就是这个进程中过的一个线程，也称为主线程。即：**一个 Java 程序的运行是 main 线程和多个其他线程同时运行**。

#### 2、进程和线程的关系(JVM角度)

##### 图解进程和线程的关系

![.\pictures\图解进程和线程的关系.png](.\pictures\图解进程和线程的关系.png)

从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器**、**虚拟机栈** 和 **本地方法栈**。

##### 程序计数器为什么是私有的

程序计数器主要有下面两个作用：

- 字节码解释器通过改变程序计数器(即：下一条指令的地址)来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

总结：所以，程序计数器私有主要是为了***线程切换后能恢复到正确的执行位置***。

##### 虚拟机栈和本地方法栈为什么是私有的

虚拟机栈：每个java方法执行都会创建一个帧栈用于存储局部变量表、操作数栈、常量池引用等。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

本地方法栈：和虚拟机栈类似。但是主要区别在于：虚拟机栈为虚拟机执行java方法(也就是字节码)服务，而本地方法栈为虚拟机使用到的Native方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

总结：所以，二者私有的主要原因是，***保证线程的局部变量不被其他线程访问到***。

#### 3、并发与并行的区别

“并发”指的是程序的结构，“并行”指的是程序运行时的状态

- **并发：** 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；
- **并行：**即同时执行，判断程序是否处于并行的**状态**，就看同一时刻是否有超过一个“工作单位”在运行就好了。所以，**单线程永远无法达到并行状态**。

**并行指物理上同时执行，并发指能够让多个任务在逻辑上交织执行的程序设计**

#### 4、为什么要使用多线程

总体上来说：

**从计算机底层来说**：1）线程开销本地低(线程间切换和调度)  2）多核CPU支持多个线程同时执行，这减少线程上下文切换的开销

**从当代互联网发展趋势来说**：系统并发量越来越高。多线程并发编程时开发高并发系统的基础，能有效提高系统整体的并发能力和性能

再深入到计算机底层来探讨：

**单核时代**：能有效提高CPU和IO设备的利用率。创建多个线程让CPU和IO设备同时执行。

**多核时代**：主要是为了提高 CPU 利用率。创建多个线程让多个CPU同时被使用。

#### 5、使用多线程可能带来什么问题

多线程虽让让提高程序的执行速度，但是也带来了很多问题。如:内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。

#### 6、java线程的生命周期及状态

![.\pictures\java线程的五种基本状态.webp](.\pictures\java线程的五种基本状态.webp)

- 新建状态（New）

  > 当线程对象创建后，即进入新建状态，如：`Thread t = new MyThread();`

- 就绪状态（Runnable）

  > 当调用线程对象的`start()`方法时，线程即进入就绪状态。处于就绪状态的线程只是说明此线程已经做好准备，随时等待CPU调度执行，并不是说执行了`start()`方法就立即执行。

- 运行状态（Running）

  > 当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。

- 阻塞状态（Blocked）

  > 处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。
  >
  > **阻塞状态分类**
  >
  > 1. 等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；
  > 2. 同步阻塞：线程在获取`synchronized`同步锁失败（因为锁被其它线程占用），它会进入到同步阻塞状态；
  > 3. 其他阻塞：通过调用线程的sleep()或join()或发出I/O请求时，线程会进入到阻塞状态。当`sleep()`状态超时、`join()`等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

- 死亡状态

  > 线程执行完毕或者是异常退出，该线程结束生命周期。

#### 7、什么是上下文切换

**概念**

当前任务执行完CPU时间片切换到另外一个任务时会保存当前执行状态，以便下次继续执行这个任务。**任务从保存到再加载的过程就是一次上下文切换**。

**时间的消耗**

上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。

Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。

####  8、什么是线程死锁?如何避免死锁?

**概念**

多个线程都处于阻塞状态，而这些处于阻塞状态的线程需要别的阻塞状态线程所拥有的资源才能执行。

**死锁原因**

需满足以下四个条件：

1、互斥条件：该资源任意一个时刻只由一个线程占用

2、请求与保持条件：执行过程种因请求资源而阻塞，对占有资源不释放。

3、不剥夺条件：执行结束前，已占有资源不被其他线程剥夺。

4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

**避免死锁**

只要破坏产生死锁的四个条件中的其中一个就可以了。

1、破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。

2、破坏请求与保持条件：一次性申请所有的资源。（执行过程中不再请求资源）

3、破坏不剥夺条件：申请不到资源时释放占有资源。（强行剥夺占有资源）

4、破坏循环等待条件：按顺序申请资源（如果资源已被申请，不让其申请）

#### 9、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？

总结：调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。

所以直接调用run() 会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它。所以这并不是多线程工作。

#### 10、sleep() 和 wait()异同

共同点:都可以暂停线程的执行

|          | sleep()  | wait()                                                       |
| -------- | -------- | ------------------------------------------------------------ |
| 释放锁   | N        | Y                                                            |
| 自动唤醒 | Y        | N  需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法 |
| 使用场景 | 暂停执行 | 线程间交互/通信                                              |

### 进阶面试

#### 1、synchronized 关键字

**1.1 说说对synchronized 关键字的了解**

synchronized 关键字解决的是***多线程访问资源的同步性***，synchronized 关键字可以保证被修饰的方法或代码块在同一时刻只能有一个线程执行。

**1.2 你自己怎么使用synchronized 关键字，项目中有用到吗**

**synchronized关键字最主要的三种使用方式**

- 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁

- 修饰静态方法：当前类加锁，会作用于类的所有对象实例

- 修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

​    ***总结*：**`synchronized` 关键字修饰静态方法和代码块都是给类加锁，修饰实例方法是给实例对象上锁。

尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！

（参考：[记一次synchronized锁字符串引发的坑兼再谈Java字符串](https://www.cnblogs.com/xrq730/p/6662232.html)）

**具体使用实例**

面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！

~~~java
双重校验锁实现对象单例（线程安全）
public class Singleton(){
	private valatile static  Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton(){
    	//1 判断对象是否已经实例过，没有实例化过才进入加锁代码
    	if(uniqueInstance == null){
    	 	//2 类对象加锁
    		synchronized(Singleton.class){
    			if(uniqueInstance == null){
    				uniqueInstance = new Singleton();
    			}
    		}
    	}
    	return uniqueInstance;
    }
}
~~~

需要注意的是，这里用volatile是有必要的。

 uniqueInstance = new Singleton();分三步执行：1）分配空间；2）初始化对象；3）将uniqueInstance指向内存地址

但是，jvm具有指令重排特性，顺序可能为：1—>3—>2，多线程情况下可能获取到刚执行完3的uniqueInstance，此时uniqueInstance不为null,为一个未初始化的实例对象，这显示是有问题的。

所有，使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。

**1.3 synchronized 原理**

synchronized 关键字底层原理属于 JVM 层面。

**① synchronized 同步语句块的情况**

```java
public class SynchronizedDemo {
	public void method() {
		synchronized (this) {
			System.out.println("synchronized 代码块");
		}
	}
```

通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 `javac SynchronizedDemo.java` 命令生成编译后的 .class 文件，然后执行`javap -c -s -v -l SynchronizedDemo.class`。

![(.\pictures\sychronized底层原理_同步语句块.png](.\pictures\sychronized底层原理_同步语句块.png)

从上面我们可以看出：

synchronized 同步语句块的实现使用的是 **monitorenter** 和 **monitorexit** 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 

当执行 monitorenter 指令时，线程试图获取锁也就是获取 **monitor**的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

补充monitor：monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因。

**② synchronized 修饰方法的的情况**

```java
public class SynchronizedDemo2 {
	public synchronized void method() {
		System.out.println("synchronized 方法");
	}
}
```

synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 **ACC_SYNCHRONIZED** 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

**1.4 JDK1.6 之后synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗**

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

锁的状态主要有四个：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。

注意***锁可以升级不能降级***，这中策略是为了***提高获得锁和释放锁的效率***。

总结：对锁进行了更细致的划分，在并发量不同的情况下使用不同的锁。

**①偏向锁**

引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而***偏向锁在无竞争的情况下会把整个同步都消除掉***。

**②轻量级锁**

轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。

**③自旋锁和自适应自旋**

轻量级锁失败后，虚拟机***为了避免线程真实地在操作系统层面挂起***，还会进行一项称为自旋锁的优化手段。

互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。

**一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。** 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。**为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋**。

**总结**

对于偏向锁和轻量级锁而言，是在没有多线程的竞争情况下，减少重量级锁使用操作系统使用互斥量产生的性能消耗，所以二者分别采用消除同步和CAS加锁放锁的策略代替使用互斥量。

对于自适应锁来说，需要使用互斥量来达到互斥同步的效果，所以主要需要处理互斥同步带来的线程阻塞问题，而线程阻塞对性能消耗极大，所以为了避免线程阻塞，让线程请求不到锁时等待一会儿而不被挂起，而这个技术叫做自旋。

**1.5 谈谈 synchronized和ReentrantLock 的区别**

**① 两者都是可重入锁**

两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

**② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API**

synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。

**③ ReentrantLock 比 synchronized 增加了一些高级功能**

相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：**①等待可中断；②可实现公平锁； 			③可实现选择性通知（锁可以绑定多个条件）**

- **ReentrantLock提供了一种能够中断等待锁的线程的机制**，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
- **ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。** ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。
- synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），**线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”** ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。

如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。

**④ 性能已不是选择标准**

总结：

**1.6 synchronized总结脑图**

![.\pictures\sychronized脑图.png](.\pictures\sychronized脑图.png)

## 五、JVM

### JAVA内存模型(JMM)

####  写在前面

基本问题：

- **介绍下 Java 内存区域（运行时数据区）**
- **Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）**
- **对象的访问定位的两种方式（句柄和直接指针两种方式）**

拓展问题:

- **String类和常量池**
- **8种基本类型的包装类和常量池**

#### 运行时数据区

 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。

![.\pictures\图解进程和线程的关系.png](.\pictures\图解进程和线程的关系.png)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存

#####  程序计数器

**简述**

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的***行号指示器***。

程序计数器原理具体说来：字节码解释器工作时通过改变这个计数器的值来***选取下一条***需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。

**作用**

字节码解释器通过改变程序计数器的值来依次读取下一条指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

在多线程情况下，程序计数器用于记录当前线程执行的位置，从而直到线程在被切换回来后继续从哪里执行。

**私有原因**

*为了线程切换后能恢复到正确的执行位置*

**注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**其他的因为可能存在内存动态扩容而导致内存不足问题。

##### java虚拟机栈

**描述**

与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。

Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。

**存储结构及存储内容**

Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。

![.\pictures\帧栈.png](.\pictures\帧栈.png)

局部变量表存储包含基本数据类型、对象应用。

**异常**

Java 虚拟机栈会出现两种异常：**StackOverFlowError 和 OutOfMemoryError。**

- **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

##### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

##### 堆

**简述**

是进程中最大的内存，用于存新创建的对象本身(所有对象（对象实例+数组）都在这里分配内存)

Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。

**为什么被称为GC堆**

Java堆是垃圾管理器管理的主要区域，所以又被成为GC堆（Garbage Collected  Heap）。

从垃圾回收的角度，由于现在收集器基本都采用***分代垃圾收集算法***，所以Java堆还可以细分为：***新生代和老年代***：再细致一点有：Eden空间、From Survivor、To Survivor空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存**。

![.\pictures\java堆分类图.jpg](.\pictures\java堆分类图.jpg)

**在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。**

##### 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域。

用于存常量、静态变量、已被加载的类信息(包括类的名称、方法信息、字段信息)、即时编译器编译的代码等数据。

**相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。**

##### 运行时常量池

**简述**

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**



##### 总结堆、方法区、栈

- 堆和方法区被所有线程共享，栈是线程私有的

- 堆  是进程中最大的内存，用于存新创建的对象本身(所有的对象（对象实例+数组）都在这里分配内存)

- 方法区  存常量、静态变量、已被加载的类信息(包括类的名称、方法信息、字段信息)、即时编译器编译的代码等数据

- 栈  用于存放基础数据类型和对象引用

## 三、Lambad表达式



## 四、聚合操作即



## 五、JAR文件打包



## 六、国际化



## 七、反射

额ei 

## 八、安全性





## 九、扩展机制-自定义API



## 十、泛型-对类型系统的增强





















 